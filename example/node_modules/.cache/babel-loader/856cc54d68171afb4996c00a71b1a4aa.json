{"ast":null,"code":"import React, { useEffect, useMemo } from 'react';\nimport resso from 'resso';\nexport { default as resso } from 'resso';\nclass Art {\n  static setup(config) {\n    if (config) {\n      this.config = {\n        ...this.config,\n        ...config\n      };\n      if (this.config.axios) {\n        this.axios = this.config.axios.create({\n          baseURL: this.config.baseURL\n        });\n      }\n    }\n  }\n}\nArt.config = {\n  showErrorMessage: res => {\n    console.log(res);\n  },\n  showSuccessMessage: res => {\n    console.log(res);\n  },\n  handlePage: (page, pageSize) => {\n    return {\n      page,\n      pageSize\n    };\n  },\n  handleHttpResult: resBody => {\n    const {\n      success,\n      errorCode,\n      errorMessage,\n      payload,\n      count\n    } = resBody || {};\n    return {\n      success,\n      code: errorCode,\n      message: errorMessage,\n      data: payload,\n      total: count\n    };\n  }\n};\nvar ViewState;\n(function (ViewState) {\n  ViewState[ViewState[\"idle\"] = 0] = \"idle\";\n  ViewState[ViewState[\"busy\"] = 1] = \"busy\";\n  ViewState[ViewState[\"error\"] = 2] = \"error\";\n})(ViewState || (ViewState = {}));\nconst dataCache = new Map();\nfunction createCacheKey(key, ids) {\n  const prefix = 'key';\n  return `${prefix}_${key}` + (ids === null || ids === void 0 ? void 0 : ids.map(id => `_${id}`));\n}\nfunction setCache(key, data) {\n  dataCache.set(key, data);\n}\nfunction getCache(key) {\n  return dataCache.get(key);\n}\nfunction clearCache(key) {\n  dataCache.delete(key);\n}\nfunction getAxiosRequest(method, url, body, config) {\n  switch (method) {\n    case 'POST':\n    case 'post':\n      return Art.axios.post(url, body, config);\n    case 'PUT':\n    case 'put':\n      return Art.axios.put(url, body, config);\n    case 'DELETE':\n    case 'delete':\n      return Art.axios.delete(url, config);\n    default:\n      return Art.axios.get(url, config);\n  }\n}\nfunction handleError(e) {\n  if (Art.config.axios.isCancel(e)) {\n    return {\n      success: false,\n      isCancel: true,\n      message: e.message\n    };\n  } else {\n    const response = e.response;\n    if (response) {\n      const axiosRes = e;\n      if (Art.config.handleHttpErrorResult) {\n        return {\n          message: axiosRes.message,\n          ...Art.config.handleHttpErrorResult(response),\n          success: false,\n          status: response.status,\n          isCancel: false\n        };\n      } else {\n        return {\n          success: false,\n          status: response.status,\n          code: axiosRes.code,\n          message: axiosRes.message,\n          isCancel: false\n        };\n      }\n    } else {\n      throw new Error(e);\n    }\n  }\n}\nfunction updateDefaultBody(store, defaultBody, body) {\n  let _body;\n  if (defaultBody) {\n    let _defaultBody;\n    if (typeof defaultBody === 'function') {\n      _defaultBody = defaultBody();\n    } else {\n      _defaultBody = defaultBody;\n    }\n    _body = {\n      ..._defaultBody,\n      ...(body ?? {})\n    };\n  } else {\n    _body = body;\n  }\n  store.body = _body;\n}\nfunction handlePageBody(store, usePage) {\n  let _body = store.body;\n  if (usePage) {\n    const _store = store;\n    if (Art.config.handlePage) {\n      _body = {\n        ...(_body ?? {}),\n        ...Art.config.handlePage(_store.current, _store.pageSize)\n      };\n    } else {\n      _body = {\n        ...(_body ?? {}),\n        current: _store.current,\n        pageSize: _store.pageSize\n      };\n    }\n  }\n  return _body;\n}\nfunction getPostBody(body, postBody) {\n  let _body = body;\n  if (postBody && _body) {\n    _body = postBody(_body);\n  }\n  return _body;\n}\nfunction autoClear(store, autoClear) {\n  if (autoClear) {\n    store.clear();\n  }\n}\nfunction getMyConfig(config) {\n  const defaultConfig = {\n    status: true,\n    loading: false,\n    isDefaultSet: true,\n    autoClear: false,\n    cacheTime: 300000,\n    staleTime: 0,\n    showMessage: true,\n    showSuccessMessage: false,\n    showErrorMessage: true\n  };\n  return {\n    ...defaultConfig,\n    ...(config ?? {})\n  };\n}\nfunction handleStartLoading(config) {\n  if (config.loading && config.startLoading) {\n    config.startLoading();\n  }\n}\nfunction handleEndLoading(config) {\n  if (config.loading && config.startLoading) {\n    config.startLoading();\n  }\n}\nasync function doRequest(request, store, config, setData) {\n  handleStartLoading(config);\n  const setStatus = async status => {\n    const loadingWait = async () => {\n      if (status !== ViewState.busy && config.loadingDelayMs) {\n        await waitTime(config.loadingDelayMs);\n      }\n    };\n    if (config !== null && config !== void 0 && config.status) {\n      await loadingWait();\n      store.setStatus(status);\n    }\n  };\n  let myRes;\n  try {\n    await setStatus(ViewState.busy);\n    const res = await request.request();\n    myRes = config.handleHttpResult ? config.handleHttpResult(res) : Art.config.handleHttpResult ? Art.config.handleHttpResult(res) : res;\n    store.originData = myRes.data;\n    if (config.postData) {\n      myRes.data = config.postData(myRes.data);\n    }\n    await setStatus(ViewState.idle);\n  } catch (e) {\n    myRes = handleRequestCatch(e, request);\n    if (!myRes.isCancel) {\n      await setStatus(ViewState.error);\n    } else {\n      await setStatus(ViewState.idle);\n    }\n  }\n  setData(myRes);\n  handleCallback(config, myRes);\n  handleMessage(config, myRes);\n  handleEndLoading(config);\n  return myRes;\n}\nfunction handleMessage(config, res) {\n  if (config.showMessage) {\n    if (res.success && config.showSuccessMessage && Art.config.showSuccessMessage) {\n      Art.config.showSuccessMessage(res);\n    } else if (!res.success && config.showErrorMessage && Art.config.showErrorMessage) {\n      Art.config.showErrorMessage(res);\n    }\n  }\n}\nfunction handleCallback(config, res) {\n  if (res.success) {\n    if (config.successCallback) {\n      config.successCallback(res, false);\n    }\n  } else if (!res.isCancel) {\n    if (config.failCallback) {\n      config.failCallback(res);\n    }\n  }\n  if (config.onLoadComplete) {\n    config.onLoadComplete(res);\n  }\n}\nfunction handleRequestCatch(e, request) {\n  let result = {\n    success: false,\n    isCancel: false,\n    message: e\n  };\n  if (request.type === 'axios') {\n    result = handleError(e);\n  }\n  if (Art.config.handleHttpError) {\n    Art.config.handleHttpError(e);\n  }\n  console.log(e);\n  return result;\n}\nfunction getRequest(request, body, method) {\n  let _request;\n  let source;\n  if (typeof request === 'function') {\n    _request = () => request(body);\n  } else {\n    let url = request;\n    const isPathParams = url.includes('{') && url.includes('}');\n    const _method = method ?? (isPathParams ? 'GET' : body ? 'POST' : 'GET');\n    const isPost = method === 'POST' || method === 'post';\n    if (body && typeof body === 'object' && isPathParams) {\n      Object.keys(body).forEach(key => {\n        url = url.replace(new RegExp('\\\\{' + key + '\\\\}', 'g'), body[key]);\n      });\n    }\n    if (Art.config.axios != null) {\n      source = Art.config.axios.CancelToken.source();\n      _request = () => getAxiosRequest(_method, url, body ?? (isPost ? {} : undefined), {\n        cancelToken: source.token\n      });\n    } else {\n      throw new Error('Coco 必须实例化 http 组件，目前支持axios');\n    }\n  }\n  return {\n    request: _request,\n    type: 'axios',\n    source\n  };\n}\nfunction setBody(store, inBody) {\n  let replace = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;\n  const {\n    body\n  } = store;\n  if (body && !replace) {\n    store.body = {\n      ...inBody,\n      ...store.body\n    };\n  } else {\n    store.body = inBody;\n  }\n}\nconst waitTime = function () {\n  let time = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 100;\n  return new Promise(resolve => {\n    setTimeout(() => {\n      resolve(true);\n    }, time);\n  });\n};\nfunction doRun(request, config) {\n  if (config.throttleMs) {\n    return throttle(request, config.throttleMs);\n  }\n  return debounce(request, config.debounceMs);\n}\nfunction debounce(request, ms) {\n  let timeout;\n  return (body, config) => {\n    clearTimeout(timeout);\n    return new Promise(resolve => {\n      if (ms) {\n        timeout = setTimeout(() => {\n          resolve(request(body, config));\n        }, ms);\n      } else {\n        resolve(request(body, config));\n      }\n    });\n  };\n}\nfunction throttle(request, waitMs) {\n  let timeout;\n  let old = 0;\n  return (body, config) => {\n    return new Promise(resolve => {\n      const now = new Date().valueOf();\n      if (!old) {\n        old = now;\n      }\n      if (now - old > waitMs) {\n        if (timeout) {\n          clearTimeout(timeout);\n          timeout = null;\n        }\n        resolve(request(body, config));\n        old = now;\n      } else if (!timeout) {\n        timeout = setTimeout(() => {\n          old = new Date().valueOf();\n          timeout = null;\n          resolve(request(body, config));\n        }, waitMs);\n      }\n    });\n  };\n}\nfunction setStoreCacheData(config, request, store, res) {\n  if (!config.cache) {\n    return;\n  }\n  const key = getCacheKey(config, request, store);\n  let pagination;\n  try {\n    if (config.usePage) {\n      const {\n        current,\n        pageSize,\n        total,\n        offset\n      } = store;\n      pagination = {\n        current,\n        pageSize,\n        total,\n        offset\n      };\n    }\n  } catch (e) {}\n  setCache(key, {\n    body: store.body,\n    data: res,\n    time: new Date().getTime(),\n    pagination\n  });\n}\nfunction getStoreCacheData(config, request, store) {\n  if (!config.cache) {\n    return {\n      cache: undefined,\n      active: false\n    };\n  }\n  const key = getCacheKey(config, request, store);\n  const cache = getCache(key);\n  if (cache) {\n    const cacheTime = config.cacheTime ?? 300000;\n    if (cacheTime < 0 || new Date().getTime() - cache.time <= cacheTime) {\n      return {\n        cache,\n        active: true\n      };\n    } else {\n      clearCache(key);\n    }\n  }\n  return {\n    cache: undefined,\n    active: false\n  };\n}\nfunction getCacheRequest(config, cache, store) {\n  const res = cache.data;\n  if (config.successCallback) {\n    config.successCallback(res, true);\n  }\n  if (cache.pagination) {\n    try {\n      const _store = store;\n      const {\n        current,\n        pageSize,\n        total,\n        offset\n      } = cache.pagination;\n      _store.current = current;\n      _store.pageSize = pageSize;\n      _store.total = total;\n      _store.offset = offset;\n    } catch (e) {}\n  }\n  store.data = cache.data.data;\n  store.body = cache.body;\n  const staleTime = config.staleTime ?? 0;\n  if (staleTime >= 0 && new Date().getTime() - cache.time > staleTime) {\n    store.refresh().then();\n  }\n  return new Promise(resolve => resolve(res));\n}\nfunction getCacheKey(config, request, store) {\n  let key;\n  if (config.cache === true || typeof config.cache === 'function') {\n    if (typeof request === 'function') {\n      throw new Error('request是url的形式的时候，cache只能是字符串');\n    }\n  }\n  if (typeof config.cache === 'string') {\n    key = createCacheKey(config.cache);\n  } else if (typeof config.cache === 'function') {\n    const ids = config.cache(store.body);\n    key = createCacheKey(request, ids);\n  } else {\n    key = createCacheKey(request);\n  }\n  if (config.usePage) {\n    const {\n      current,\n      pageSize,\n      offset\n    } = store;\n    return `${key}_${current}_${pageSize}` + offset ? `'_${offset}'` : '';\n  }\n  return key;\n}\nconst document = window ? window.document : undefined;\nconst visible = 'visible';\nconst useBrowserPageChange = () => {\n  const [visibilityChange, setVisibilityChange] = React.useState(false);\n  const getHiddenProp = () => {\n    if (!document) {\n      return null;\n    }\n    const prefixes = ['webkit', 'moz', 'ms', 'o'];\n    if ('hidden' in document) {\n      return 'hidden';\n    }\n    for (let i = 0; i < prefixes.length; i++) {\n      if (prefixes[i] + 'Hidden' in document) return prefixes[i] + 'Hidden';\n    }\n    return null;\n  };\n  const getVisibilityState = () => {\n    const prefixes = ['webkit', 'moz', 'ms', 'o'];\n    if ('visibilityState' in document) return 'visibilityState';\n    for (let i = 0; i < prefixes.length; i++) {\n      if (prefixes[i] + 'VisibilityState' in document) return prefixes[i] + 'VisibilityState';\n    }\n    return null;\n  };\n  useEffect(() => {\n    const eventName = (getHiddenProp() ?? '').replace(/[H|h]idden/, '') + 'visibilitychange';\n    if (getHiddenProp()) {\n      document.addEventListener(eventName, function () {\n        setVisibilityChange(document[getVisibilityState() ?? ''] === visible);\n      }, false);\n    }\n    return () => {\n      document.removeEventListener(eventName, function () {\n        setVisibilityChange(document[getVisibilityState() ?? ''] === visible);\n      });\n    };\n  }, [getHiddenProp()]);\n  return {\n    visibilityChange\n  };\n};\nfunction createQueryStore(request, config) {\n  let myConfig = getMyConfig(config);\n  let currentRequest;\n  function setResData(res) {\n    if (res.success) {\n      var _myConfig;\n      if (myConfig.isDefaultSet) {\n        store.setData(res.data);\n        store.total = res.total ?? 0;\n      }\n      if ((_myConfig = myConfig) !== null && _myConfig !== void 0 && _myConfig.status && (store === null || store === void 0 ? void 0 : store.status) !== ViewState.error) {\n        store.isEmpty = !res.data || res.data && res.data instanceof Array && !res.data.length;\n      }\n      store.lastRequestTime = new Date().getTime();\n      setStoreCacheData(myConfig, request, store, res);\n    } else if (!res.isCancel) {\n      store.error = {\n        message: res.message,\n        code: res.code,\n        status: res.status\n      };\n    }\n  }\n  const store = resso({\n    isBusy: false,\n    isError: false,\n    status: ViewState.idle,\n    isEmpty: undefined,\n    error: undefined,\n    setStatus: status => {\n      store.status = status;\n      store.isError = status === ViewState.error;\n      store.isBusy = status === ViewState.busy;\n    },\n    lastRequestTime: undefined,\n    body: undefined,\n    setBody: function (inBody) {\n      let replace = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;\n      setBody(store, inBody, replace);\n    },\n    current: 1,\n    pageSize: (config === null || config === void 0 ? void 0 : config.pageSize) ?? 10,\n    total: 0,\n    offset: undefined,\n    setPage: config => {\n      const {\n        current,\n        pageSize\n      } = config ?? {};\n      if (current) {\n        store.current = current;\n      }\n      if (pageSize) {\n        store.pageSize = pageSize;\n      }\n      return store.run();\n    },\n    originData: undefined,\n    data: undefined,\n    setData: data => {\n      store.data = data;\n    },\n    refresh: config => {\n      myConfig = {\n        ...myConfig,\n        loading: false,\n        status: false,\n        ...(config ?? {}),\n        refresh: true\n      };\n      if (!currentRequest) {\n        return store.run(undefined, myConfig);\n      } else {\n        return doRequest(currentRequest, store, myConfig, setResData);\n      }\n    },\n    run: doRun((body, config) => {\n      myConfig = {\n        ...myConfig,\n        ...config\n      };\n      autoClear(store, myConfig.autoClear);\n      console.log(store);\n      const {\n        cache,\n        active\n      } = getStoreCacheData(myConfig, request, store);\n      if (!(config !== null && config !== void 0 && config.refresh) && cache && active) {\n        return getCacheRequest(myConfig, cache, store);\n      } else {\n        updateDefaultBody(store, myConfig.defaultBody, body);\n        let _body = handlePageBody(store, myConfig.usePage);\n        _body = getPostBody(_body, myConfig.postBody);\n        currentRequest = getRequest(request, _body, myConfig.method);\n        return doRequest(currentRequest, store, myConfig, setResData);\n      }\n    }, myConfig),\n    cancel: message => {\n      if (currentRequest) {\n        if (currentRequest.type === 'axios') {\n          var _currentRequest$sourc;\n          (_currentRequest$sourc = currentRequest.source) === null || _currentRequest$sourc === void 0 ? void 0 : _currentRequest$sourc.cancel(message);\n        }\n      }\n    },\n    clear: () => {\n      store.data = undefined;\n      store.body = undefined;\n      store.total = 0;\n      store.current = 1;\n      store.isEmpty = undefined;\n    }\n  });\n  return store;\n}\nfunction useQuery(request, config, deps) {\n  const store = useMemo(() => createQueryStore(request, config), deps ?? []);\n  useEffect(() => {\n    const manual = (config === null || config === void 0 ? void 0 : config.manual) ?? false;\n    if (!manual) {\n      store.run().then();\n    }\n    let interval;\n    if (config !== null && config !== void 0 && config.pollingIntervalMs) {\n      if (interval) {\n        clearInterval(interval);\n      }\n      interval = setInterval(() => {\n        store.run().then();\n      }, config === null || config === void 0 ? void 0 : config.pollingIntervalMs);\n    }\n    return () => {\n      if (interval) {\n        clearInterval(interval);\n      }\n      store.cancel();\n    };\n  }, deps ?? []);\n  const {\n    visibilityChange\n  } = useBrowserPageChange();\n  useEffect(() => {\n    if (config !== null && config !== void 0 && config.refreshOnWindowFocus && visibilityChange) {\n      if (!store.lastRequestTime || new Date().getTime() - store.lastRequestTime > ((config === null || config === void 0 ? void 0 : config.refreshOnWindowFocusTimespanMs) ?? 0)) if ((config === null || config === void 0 ? void 0 : config.refreshOnWindowFocusMode) === 'run') {\n        store.run().then();\n      } else {\n        store.refresh().then();\n      }\n    }\n  }, [visibilityChange]);\n  return store;\n}\nfunction createSubmitStore(request, config) {\n  let myConfig = getMyConfig(config);\n  let currentRequest;\n  function setResData(res) {\n    if (res.success) {\n      var _myConfig;\n      if (myConfig.isDefaultSet) {\n        store.setData(res.data);\n      }\n      if ((_myConfig = myConfig) !== null && _myConfig !== void 0 && _myConfig.status && (store === null || store === void 0 ? void 0 : store.status) !== ViewState.error) {\n        store.isEmpty = !res.data || res.data && res.data instanceof Array && !res.data.length;\n      }\n      store.lastRequestTime = new Date().getTime();\n      setStoreCacheData(myConfig, request, store, res);\n    } else if (!res.isCancel) {\n      store.error = {\n        message: res.message,\n        code: res.code,\n        status: res.status\n      };\n    }\n  }\n  const store = resso({\n    isBusy: false,\n    isError: false,\n    status: ViewState.idle,\n    isEmpty: undefined,\n    error: undefined,\n    setStatus: status => {\n      store.status = status;\n      store.isError = status === ViewState.error;\n      store.isBusy = status === ViewState.busy;\n    },\n    lastRequestTime: undefined,\n    body: undefined,\n    setBody: function (inBody) {\n      let replace = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;\n      setBody(store, inBody, replace);\n    },\n    originData: undefined,\n    data: undefined,\n    setData: data => {\n      store.data = data;\n    },\n    refresh: config => {\n      myConfig = {\n        ...myConfig,\n        loading: false,\n        status: false,\n        ...(config ?? {}),\n        refresh: true\n      };\n      if (!currentRequest) {\n        return store.run(undefined, myConfig);\n      } else {\n        return doRequest(currentRequest, store, myConfig, setResData);\n      }\n    },\n    run: doRun((body, config) => {\n      myConfig = {\n        ...myConfig,\n        ...config\n      };\n      autoClear(store, myConfig.autoClear);\n      const {\n        cache,\n        active\n      } = getStoreCacheData(myConfig, request, store);\n      if (!(config !== null && config !== void 0 && config.refresh) && cache && active) {\n        return getCacheRequest(myConfig, cache, store);\n      } else {\n        updateDefaultBody(store, myConfig.defaultBody, body);\n        let _body = handlePageBody(store, myConfig.usePage);\n        _body = getPostBody(_body, myConfig.postBody);\n        currentRequest = getRequest(request, _body, myConfig.method);\n        return doRequest(currentRequest, store, myConfig, setResData);\n      }\n    }, myConfig),\n    cancel: message => {\n      if (currentRequest) {\n        if (currentRequest.type === 'axios') {\n          var _currentRequest$sourc;\n          (_currentRequest$sourc = currentRequest.source) === null || _currentRequest$sourc === void 0 ? void 0 : _currentRequest$sourc.cancel(message);\n        }\n      }\n    },\n    clear: () => {\n      store.data = undefined;\n      store.body = undefined;\n      store.isEmpty = undefined;\n    }\n  });\n  return store;\n}\nfunction useSubmit(request, config, deps) {\n  const store = useMemo(() => createSubmitStore(request, config), deps ?? []);\n  useEffect(() => {\n    const manual = (config === null || config === void 0 ? void 0 : config.manual) ?? true;\n    if (!manual) {\n      store.run().then();\n    }\n    let interval;\n    if (config !== null && config !== void 0 && config.pollingIntervalMs) {\n      if (interval) {\n        clearInterval(interval);\n      }\n      interval = setInterval(() => {\n        store.run().then();\n      }, config === null || config === void 0 ? void 0 : config.pollingIntervalMs);\n    }\n    return () => {\n      if (interval) {\n        clearInterval(interval);\n      }\n      store.cancel();\n    };\n  }, deps ?? []);\n  const {\n    visibilityChange\n  } = useBrowserPageChange();\n  useEffect(() => {\n    if (config !== null && config !== void 0 && config.refreshOnWindowFocus && visibilityChange) {\n      if (!store.lastRequestTime || new Date().getTime() - store.lastRequestTime > ((config === null || config === void 0 ? void 0 : config.refreshOnWindowFocusTimespanMs) ?? 0)) if ((config === null || config === void 0 ? void 0 : config.refreshOnWindowFocusMode) === 'run') {\n        store.run().then();\n      } else {\n        store.refresh().then();\n      }\n    }\n  }, [visibilityChange]);\n  return store;\n}\nexport { Art, ViewState, createQueryStore, createSubmitStore, useQuery, useSubmit };","map":{"version":3,"mappings":"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","names":["Art","setup","config","axios","create","baseURL","showErrorMessage","res","console","log","showSuccessMessage","handlePage","page","pageSize","handleHttpResult","resBody","success","errorCode","errorMessage","payload","count","code","message","data","total","ViewState","dataCache","Map","createCacheKey","key","ids","prefix","map","id","setCache","set","getCache","get","clearCache","delete","getAxiosRequest","method","url","body","post","put","handleError","e","isCancel","response","axiosRes","handleHttpErrorResult","status","Error","updateDefaultBody","store","defaultBody","_body","_defaultBody","handlePageBody","usePage","_store","current","getPostBody","postBody","autoClear","clear","getMyConfig","defaultConfig","loading","isDefaultSet","cacheTime","staleTime","showMessage","handleStartLoading","startLoading","handleEndLoading","doRequest","request","setData","setStatus","loadingWait","busy","loadingDelayMs","waitTime","myRes","originData","postData","idle","handleRequestCatch","error","handleCallback","handleMessage","successCallback","failCallback","onLoadComplete","result","type","handleHttpError","getRequest","_request","source","isPathParams","includes","_method","isPost","Object","keys","forEach","replace","RegExp","CancelToken","undefined","cancelToken","token","setBody","inBody","time","Promise","resolve","setTimeout","doRun","throttleMs","throttle","debounce","debounceMs","ms","timeout","clearTimeout","waitMs","old","now","Date","valueOf","setStoreCacheData","cache","getCacheKey","pagination","offset","getTime","getStoreCacheData","active","getCacheRequest","refresh","then","document","window","visible","useBrowserPageChange","visibilityChange","setVisibilityChange","React","useState","getHiddenProp","prefixes","i","length","getVisibilityState","useEffect","eventName","addEventListener","removeEventListener","createQueryStore","myConfig","currentRequest","setResData","_myConfig","isEmpty","Array","lastRequestTime","resso","isBusy","isError","setPage","run","cancel","_currentRequest$sourc","useQuery","deps","useMemo","manual","interval","pollingIntervalMs","clearInterval","setInterval","refreshOnWindowFocus","refreshOnWindowFocusTimespanMs","refreshOnWindowFocusMode","createSubmitStore","useSubmit"],"sources":["../src/lib/art.ts","../src/lib/model.ts","../src/lib/cache.ts","../src/lib/axios/index.ts","../src/lib/utils.ts","../src/lib/hooks/browser-page-hooks.tsx","../src/lib/query.ts","../src/lib/submit.ts"],"sourcesContent":["import { UseResult } from './model'\nimport { AxiosInstance, AxiosStatic } from './axios/axios'\n\nexport interface TemplateConfigOptions {\n  baseURL?: string\n  axios?: AxiosStatic | any\n  showErrorMessage?: (res: UseResult) => void\n  showSuccessMessage?: (res: UseResult) => void\n  startLoading?: () => void\n  endLoading?: () => void\n  handleHttpResult?: (res: any) => UseResult\n  handleHttpErrorResult?: (resError: any) => UseResult\n  handlePage?: (current: number, pageSize: number) => any\n  handleHttpError?: <T>(resError: T) => void\n}\n\nexport class Art {\n  static axios?: AxiosInstance\n\n  // Default global configuration\n  static config: TemplateConfigOptions = {\n    showErrorMessage: (res) => {\n      console.log(res)\n    },\n    showSuccessMessage: (res) => {\n      console.log(res)\n    },\n    handlePage: (page, pageSize) => {\n      return { page, pageSize }\n    },\n    handleHttpResult: (resBody: any): UseResult<any> => {\n      const { success, errorCode, errorMessage, payload, count } = resBody || {}\n      return {\n        success,\n        code: errorCode,\n        message: errorMessage,\n        data: payload,\n        total: count\n      }\n    }\n  }\n\n  /**\n   * Set global configuration\n   * @param config\n   */\n  static setup(config?: TemplateConfigOptions): void {\n    if (config) {\n      this.config = { ...this.config, ...config }\n      if (this.config.axios) {\n        this.axios = this.config.axios.create({ baseURL: this.config.baseURL })\n      }\n    }\n  }\n}\n","export type Method =\n  | 'get'\n  | 'GET'\n  | 'delete'\n  | 'DELETE'\n  | 'head'\n  | 'HEAD'\n  | 'options'\n  | 'OPTIONS'\n  | 'post'\n  | 'POST'\n  | 'put'\n  | 'PUT'\n  | 'patch'\n  | 'PATCH'\n  | 'purge'\n  | 'PURGE'\n  | 'link'\n  | 'LINK'\n  | 'unlink'\n  | 'UNLINK'\n\n/**\n * API request status\n */\nexport enum ViewState {\n  idle,\n  busy,\n  error\n}\n\n/**\n * API return value object\n */\nexport interface UseResult<T = unknown> {\n  success?: boolean\n  data?: T\n  message?: string\n  code?: string\n  status?: string\n  total?: number\n  isCancel?: boolean\n  other?: any\n}\n\nexport type GetDefaultBody<T> = () => T\nexport type DefaultBodyType<T> = GetDefaultBody<T> | Partial<T> | T\n\nexport type RequestType<T = unknown> = (body?: Partial<T>) => Promise<any>\nexport type BaseConfig<R = unknown, P = unknown> = {\n  status?: boolean\n  loading?: boolean\n  isDefaultSet?: boolean\n  startLoading?: () => void\n  endLoading?: () => void\n  defaultBody?: DefaultBodyType<P> // 默认请求体\n  method?: Method // 方法\n  postBody?: (body: QueryBody<P>) => any // 转换body\n  autoClear?: boolean // 自动清空\n  showMessage?: boolean // 是否显示成功失败消息\n  showErrorMessage?: boolean // 是否显示错误消息\n  showSuccessMessage?: boolean // 是否显示成功消息\n  successCallback?: (res: UseResult<R>, cache: boolean) => void\n  failCallback?: (res: UseResult<R>) => void\n  onLoadComplete?: (res: UseResult<R>) => void\n  handleHttpResult?: (res: any) => UseResult<R>\n  postData?: (data: any) => R\n  loadingDelayMs?: number\n  debounceMs?: number\n  throttleMs?: number\n  cache?: boolean | string | ((body?: P) => string[])\n  cacheKey?: boolean\n  cacheTime?: number // 设置缓存数据回收时间 默认缓存数据 5 分钟后回收\n  staleTime?: number // 缓存数据保持新鲜时间\n}\n\nexport type ErrorType = {\n  message?: string\n  code?: string\n  status?: string\n  info?: any\n}\n\nexport type StorePageConfig = {\n  usePage?: boolean\n  pageSize?: number\n}\n\nexport type SubmitConfig<R = unknown, P = unknown> = BaseConfig<R, P> &\n  QueryRunConfig\n\nexport type QueryConfig<R = unknown, P = unknown> = BaseConfig<R, P> &\n  QueryRunConfig &\n  StorePageConfig\n\nexport type RefreshConfigType = { status?: boolean; loading?: boolean }\n\nexport type QueryRunConfig = RefreshConfigType & {\n  refresh?: boolean\n}\n\nexport type HooksConfig<R, P> = SubmitConfig<R, P> & {\n  manual?: boolean // 是否手动触发\n  pollingIntervalMs?: number\n  refreshOnWindowFocus?: boolean\n  refreshOnWindowFocusMode?: 'run' | 'refresh'\n  refreshOnWindowFocusTimespanMs?: number // 重新请求间隔，单位为毫秒\n}\n\nexport type QueryHooksConfig<R, P> = QueryConfig<R, P> & HooksConfig<R, P>\nexport type SubmitHooksConfig<R, P> = HooksConfig<R, P>\n\nexport type BaseQueryStoreType = {\n  status: ViewState\n  isBusy: boolean\n  isError: boolean\n  isEmpty?: boolean\n  setStatus: (status: ViewState) => void\n  lastRequestTime?: number\n  error?: ErrorType // 错误状态\n}\n\nexport type QueryBodyStoreType<P> = {\n  body?: Partial<P>\n  setBody: (body: Partial<P>, replace?: boolean) => void\n}\n\nexport type QueryDataStoreType<R = unknown> = {\n  originData?: any\n  data?: R\n  setData: (data?: R) => void\n}\n\nexport type QueryPageStoreType<R = unknown> = {\n  current: number\n  pageSize: number\n  total: number\n  offset?: string\n  setPage: (config: {\n    current?: number\n    pageSize?: number\n  }) => Promise<UseResult<R>>\n  loadMore?: () => Promise<UseResult<R>>\n}\n\nexport type QueryRunStoreType<R, P> = {\n  cancel: (message?: string) => void\n  run: (body?: Partial<P>, config?: QueryRunConfig) => Promise<UseResult<R>>\n  refresh: (config?: RefreshConfigType) => Promise<UseResult<R>>\n  clear: () => void\n}\n\nexport type StoreType<R, P> = QueryStoreType<R, P> | SubmitStoreType<R, P>\n\nexport type QueryStoreType<R, P> = BaseQueryStoreType &\n  QueryBodyStoreType<P> &\n  QueryDataStoreType<R> &\n  QueryPageStoreType<R> &\n  QueryRunStoreType<R, P>\n\nexport type SubmitStoreType<R, P> = BaseQueryStoreType &\n  QueryBodyStoreType<P> &\n  QueryDataStoreType<R> &\n  QueryRunStoreType<R, P>\n\nexport type PaginationType = {\n  current: number\n  pageSize: number\n  total: number\n  offset?: string\n}\n\nexport type CachedData<TData = unknown, TBody = unknown> = {\n  data: TData\n  body: TBody\n  pagination?: PaginationType\n  time: number\n}\n\nexport type RequestResult = {\n  type: 'axios'\n  request: () => Promise<any>\n  source?: any\n}\n\nexport type QueryBody<P> = Partial<P> & { current?: number; pageSize?: number }\n","import { CachedData } from './model'\n\nconst dataCache: Map<string, CachedData> = new Map()\n\nexport function createCacheKey(key?: string, ids?: string[]) {\n  const prefix = 'key'\n  return `${prefix}_${key}` + ids?.map((id) => `_${id}`)\n}\n\nexport function setCache<TData, TBody>(\n  key: string,\n  data: CachedData<TData, TBody>\n) {\n  dataCache.set(key, data)\n}\n\nexport function getCache<TData, TBody>(\n  key: string\n): CachedData<TData, TBody> | undefined {\n  return dataCache.get(key) as CachedData<TData, TBody> | undefined\n}\n\nexport function clearCache(key: string) {\n  dataCache.delete(key)\n}\n","import { Art } from '../art'\nimport { AxiosError, AxiosRequestConfig, Method } from './axios'\n\nexport function getAxiosRequest(\n  method: Method,\n  url: string,\n  body: any,\n  config?: AxiosRequestConfig\n): Promise<any> {\n  switch (method) {\n    case 'POST':\n    case 'post':\n      return Art.axios!.post(url, body, config)\n    case 'PUT':\n    case 'put':\n      return Art.axios!.put(url, body, config)\n    case 'DELETE':\n    case 'delete':\n      return Art.axios!.delete(url, config)\n    default:\n      return Art.axios!.get(url, config)\n  }\n}\n\nexport function handleError(e: any) {\n  if (Art.config.axios.isCancel(e)) {\n    return { success: false, isCancel: true, message: e.message }\n  } else {\n    const response = e.response\n    if (response) {\n      const axiosRes = e as AxiosError\n      if (Art.config.handleHttpErrorResult) {\n        return {\n          message: axiosRes.message,\n          ...Art.config.handleHttpErrorResult(response),\n          success: false,\n          status: response.status,\n          isCancel: false\n        }\n      } else {\n        return {\n          success: false,\n          status: response.status,\n          code: axiosRes.code,\n          message: axiosRes.message,\n          isCancel: false\n        }\n      }\n    } else {\n      throw new Error(e)\n    }\n  }\n}\n","import {\n  CachedData,\n  DefaultBodyType,\n  GetDefaultBody,\n  Method,\n  PaginationType,\n  QueryBody,\n  QueryConfig,\n  QueryRunConfig,\n  QueryStoreType,\n  RequestResult,\n  RequestType,\n  StoreType,\n  SubmitStoreType,\n  UseResult,\n  ViewState\n} from './model'\nimport { Art } from './art'\nimport { clearCache, createCacheKey, getCache, setCache } from './cache'\nimport { getAxiosRequest, handleError } from './axios'\n\n/**\n * 处理默认请求体\n * @param store 状态管理\n * @param defaultBody 默认请求内容\n * @param body 动态请求参数\n */\nexport function updateDefaultBody<P>(\n  store: StoreType<any, P>,\n  defaultBody?: DefaultBodyType<P>,\n  body?: Partial<P>\n) {\n  let _body\n  if (defaultBody) {\n    let _defaultBody\n    if (typeof defaultBody === 'function') {\n      _defaultBody = (defaultBody as GetDefaultBody<P>)()\n    } else {\n      _defaultBody = defaultBody\n    }\n    _body = { ..._defaultBody, ...(body ?? {}) }\n  } else {\n    _body = body\n  }\n  store.body = _body\n}\n\n/**\n * 添加分页请求参数\n * @param store\n * @param usePage 是否使用分页\n */\nexport function handlePageBody<R, P>(\n  store: StoreType<R, P>,\n  usePage?: boolean\n): any {\n  let _body = store.body as any\n  if (usePage) {\n    const _store = store as QueryStoreType<R, P>\n    if (Art.config.handlePage) {\n      _body = {\n        ...(_body ?? {}),\n        ...Art.config.handlePage(_store.current, _store.pageSize)\n      }\n    } else {\n      _body = {\n        ...(_body ?? {}),\n        current: _store.current,\n        pageSize: _store.pageSize\n      }\n    }\n  }\n  return _body\n}\n\n/**\n * 转化成提交之前的请求体\n * @param body\n * @param postBody\n */\nexport function getPostBody<P>(\n  body?: QueryBody<P>,\n  postBody?: (body: QueryBody<P>) => any\n) {\n  let _body = body\n  if (postBody && _body) {\n    _body = postBody(_body)\n  }\n  return _body\n}\n\n/**\n * 自动清除\n * @param store\n * @param autoClear\n */\nexport function autoClear(store: { clear: () => void }, autoClear?: boolean) {\n  if (autoClear) {\n    store.clear()\n  }\n}\n\n/**\n * 获取当前配置项目\n * @param config\n */\nexport function getMyConfig<R, P>(\n  config?: QueryConfig<R, P>\n): QueryConfig<R, P> {\n  // 初始化默认配置\n  const defaultConfig = {\n    status: true,\n    loading: false,\n    isDefaultSet: true,\n    autoClear: false,\n    cacheTime: 300000,\n    staleTime: 0,\n    showMessage: true,\n    showSuccessMessage: false,\n    showErrorMessage: true\n  } as QueryConfig<R, P>\n  // 得到当前配置\n  // @ts-ignore\n  return { ...defaultConfig, ...(config ?? {}) }\n}\n\n/**\n * 处理开始loading\n * @param config\n */\nexport function handleStartLoading(config: {\n  loading?: boolean\n  startLoading?: () => void\n}) {\n  if (config.loading && config.startLoading) {\n    config.startLoading()\n  }\n}\n\n/**\n * 处理结束loading\n * @param config\n */\nexport function handleEndLoading(config: {\n  loading?: boolean\n  startLoading?: () => void\n}) {\n  if (config.loading && config.startLoading) {\n    config.startLoading()\n  }\n}\n\nexport async function doRequest<T, P>(\n  request: RequestResult,\n  store: SubmitStoreType<T, P>,\n  config: QueryConfig<T, P>,\n  setData: (res: UseResult<T>) => void\n): Promise<UseResult<T>> {\n  // 处理开始loading\n  handleStartLoading(config)\n\n  const setStatus = async (status: ViewState) => {\n    const loadingWait = async () => {\n      if (status !== ViewState.busy && config.loadingDelayMs) {\n        await waitTime(config.loadingDelayMs)\n      }\n    }\n\n    if (config?.status) {\n      await loadingWait()\n      store.setStatus(status)\n    }\n  }\n\n  // 发送请求\n  let myRes: UseResult<T>\n  try {\n    // 设置状态\n    await setStatus(ViewState.busy)\n    // 请求接口\n    const res = await request.request()\n    // 转换数据\n    myRes = config.handleHttpResult\n      ? config.handleHttpResult(res)\n      : Art.config.handleHttpResult\n      ? Art.config.handleHttpResult(res)\n      : res\n    // 设置原始值\n    store.originData = myRes.data\n    // 转换成前端想要的数据格式\n    if (config.postData) {\n      myRes.data = config.postData(myRes.data)\n    }\n    // 设置状态\n    await setStatus(ViewState.idle)\n  } catch (e) {\n    // 处理异常\n    myRes = handleRequestCatch(e, request) as UseResult<T>\n    if (!myRes.isCancel) {\n      // 设置状态\n      await setStatus(ViewState.error)\n    } else {\n      // 设置状态\n      await setStatus(ViewState.idle)\n    }\n  }\n\n  setData(myRes)\n\n  // 处理回调\n  handleCallback<T, P>(config, myRes)\n\n  // 处理消息\n  handleMessage<T, P>(config, myRes)\n\n  // 结束loading\n  handleEndLoading(config)\n  return myRes\n}\n\n// 处理消息\nfunction handleMessage<T, P>(config: QueryConfig<T, P>, res: UseResult) {\n  if (config.showMessage) {\n    if (\n      res.success &&\n      config.showSuccessMessage &&\n      Art.config.showSuccessMessage\n    ) {\n      Art.config.showSuccessMessage(res)\n    } else if (\n      !res.success &&\n      config.showErrorMessage &&\n      Art.config.showErrorMessage\n    ) {\n      Art.config.showErrorMessage(res)\n    }\n  }\n}\n\n// 处理回调\nfunction handleCallback<T, P>(config: QueryConfig<T, P>, res: UseResult<T>) {\n  // 请求结束\n  if (res.success) {\n    if (config.successCallback) {\n      config.successCallback(res, false)\n    }\n  } else if (!res.isCancel) {\n    if (config.failCallback) {\n      config.failCallback(res)\n    }\n  }\n  if (config.onLoadComplete) {\n    config.onLoadComplete(res)\n  }\n}\n\n/**\n * 处理请求失败\n * @param e\n * @param request\n */\nfunction handleRequestCatch(e: any, request: RequestResult): UseResult {\n  let result = { success: false, isCancel: false, message: e } as UseResult\n  if (request.type === 'axios') {\n    result = handleError(e)\n  }\n\n  if (Art.config.handleHttpError) {\n    Art.config.handleHttpError(e)\n  }\n  console.log(e)\n  return result\n}\n\n/**\n * 创建请求\n * @param request 请求或者地址\n * @param body 请求阐述\n * @param method 方法\n */\nexport function getRequest(\n  request: RequestType | string,\n  body?: any,\n  method?: Method\n): RequestResult {\n  let _request: () => Promise<any>\n\n  let source: any\n\n  if (typeof request === 'function') {\n    _request = () => request(body)\n  } else {\n    let url = request as string\n    const isPathParams = url.includes('{') && url.includes('}')\n    const _method = method ?? (isPathParams ? 'GET' : body ? 'POST' : 'GET')\n    const isPost = method === 'POST' || method === 'post'\n    if (body && typeof body === 'object' && isPathParams) {\n      Object.keys(body).forEach((key) => {\n        // @ts-ignore\n        url = url.replace(new RegExp('\\\\{' + key + '\\\\}', 'g'), body[key])\n      })\n    }\n\n    if (Art.config.axios != null) {\n      source = Art.config.axios.CancelToken.source()\n      _request = () =>\n        getAxiosRequest(_method, url, body ?? (isPost ? {} : undefined), {\n          cancelToken: source.token\n        })\n    } else {\n      throw new Error('Coco 必须实例化 http 组件，目前支持axios')\n    }\n  }\n  return { request: _request, type: 'axios', source }\n}\n\nexport function setBody<P>(\n  store: { body?: Partial<P> },\n  inBody: Partial<P>,\n  replace = false\n): void {\n  const { body } = store\n  if (body && !replace) {\n    store.body = { ...inBody, ...store.body }\n  } else {\n    store.body = inBody\n  }\n}\n\n/**\n * 延迟等待\n * @param time 等待时间\n */\nexport const waitTime = (time = 100) => {\n  return new Promise((resolve) => {\n    setTimeout(() => {\n      resolve(true)\n    }, time)\n  })\n}\n\n/**\n * 处理请求\n * @param request\n * @param config\n */\nexport function doRun<R, P>(\n  request: (\n    body?: Partial<P>,\n    config?: QueryRunConfig\n  ) => Promise<UseResult<R>>,\n  config: QueryConfig<R, P>\n) {\n  if (config.throttleMs) {\n    return throttle(request, config.throttleMs)\n  }\n  return debounce(request, config.debounceMs)\n}\n\n// 防抖函数\nexport function debounce<R, P>(\n  request: (\n    body?: Partial<P>,\n    config?: QueryRunConfig\n  ) => Promise<UseResult<R>>,\n  ms?: number\n) {\n  let timeout: any\n  return (\n    body?: Partial<P>,\n    config?: QueryRunConfig\n  ): Promise<UseResult<R>> => {\n    clearTimeout(timeout)\n    return new Promise((resolve) => {\n      if (ms) {\n        timeout = setTimeout(() => {\n          resolve(request(body, config))\n        }, ms)\n      } else {\n        resolve(request(body, config))\n      }\n    })\n  }\n}\n\n// 节流函数\nexport function throttle<R, P>(\n  request: (\n    body?: Partial<P>,\n    config?: QueryRunConfig\n  ) => Promise<UseResult<R>>,\n  waitMs: number\n) {\n  let timeout: any\n  let old = 0\n  return (\n    body?: Partial<P>,\n    config?: QueryRunConfig\n  ): Promise<UseResult<R>> => {\n    return new Promise((resolve) => {\n      const now = new Date().valueOf()\n      if (!old) {\n        old = now\n      }\n      if (now - old > waitMs) {\n        if (timeout) {\n          clearTimeout(timeout)\n          timeout = null\n        }\n        resolve(request(body, config))\n        old = now\n      } else if (!timeout) {\n        timeout = setTimeout(() => {\n          old = new Date().valueOf()\n          timeout = null\n          resolve(request(body, config))\n        }, waitMs)\n      }\n    })\n  }\n}\n\n/**\n * 处理数据缓存\n * @param config\n * @param request\n * @param store\n * @param res\n */\nexport function setStoreCacheData<R, P>(\n  config: QueryConfig<R, P>,\n  request: RequestType<P> | string,\n  store: StoreType<R, P>,\n  res: UseResult<R>\n) {\n  if (!config.cache) {\n    return\n  }\n\n  const key = getCacheKey(config, request, store)\n\n  let pagination: PaginationType | undefined\n  try {\n    if (config.usePage) {\n      const { current, pageSize, total, offset } = store as QueryStoreType<R, P>\n      pagination = { current, pageSize, total, offset }\n    }\n  } catch (e) {}\n\n  setCache<UseResult<R>, P>(key, {\n    body: store.body as P,\n    data: res,\n    time: new Date().getTime(),\n    pagination\n  })\n}\n\nexport function getStoreCacheData<R, P>(\n  config: QueryConfig<R, P>,\n  request: RequestType<P> | string,\n  store: StoreType<R, P>\n) {\n  if (!config.cache) {\n    return { cache: undefined, active: false }\n  }\n\n  const key = getCacheKey(config, request, store)\n\n  const cache = getCache<UseResult<R>, P>(key)\n\n  if (cache) {\n    const cacheTime = config.cacheTime ?? 300000\n    if (cacheTime < 0 || new Date().getTime() - cache.time <= cacheTime) {\n      return { cache, active: true }\n    } else {\n      clearCache(key)\n    }\n  }\n  return { cache: undefined, active: false }\n}\n\nexport function getCacheRequest<R, P>(\n  config: QueryConfig<R, P>,\n  cache: CachedData<UseResult<R>, P>,\n  store: StoreType<R, P>\n): Promise<UseResult<R>> {\n  const res = cache.data\n  if (config.successCallback) {\n    config.successCallback(res, true)\n  }\n  if (cache.pagination) {\n    try {\n      const _store = store as QueryStoreType<R, P>\n      const { current, pageSize, total, offset } = cache.pagination\n      _store.current = current\n      _store.pageSize = pageSize\n      _store.total = total\n      _store.offset = offset\n    } catch (e) {}\n  }\n  store.data = cache.data.data\n  store.body = cache.body\n\n  // 控制新鲜度, 如果过期新鲜度\n  const staleTime = config.staleTime ?? 0\n  if (staleTime >= 0 && new Date().getTime() - cache.time > staleTime) {\n    store.refresh().then()\n  }\n  return new Promise((resolve) => resolve(res))\n}\n\nexport function getCacheKey<R, P>(\n  config: QueryConfig<R, P>,\n  request: RequestType<P> | string,\n  store: StoreType<R, P>\n) {\n  let key\n\n  if (config.cache === true || typeof config.cache === 'function') {\n    if (typeof request === 'function') {\n      throw new Error('request是url的形式的时候，cache只能是字符串')\n    }\n  }\n  if (typeof config.cache === 'string') {\n    key = createCacheKey(config.cache)\n  } else if (typeof config.cache === 'function') {\n    const ids = config.cache(store.body as P)\n    key = createCacheKey(request as string, ids)\n  } else {\n    key = createCacheKey(request as string)\n  }\n  if (config.usePage) {\n    const { current, pageSize, offset } = store as QueryStoreType<R, P>\n    return `${key}_${current}_${pageSize}` + offset ? `'_${offset}'` : ''\n  }\n  return key\n}\n","import React, { useEffect } from 'react'\n// @ts-ignore\nconst document: any = window ? window.document : undefined\nconst visible = 'visible'\n\n/**\n * 检查浏览器标签切换\n */\nexport const useBrowserPageChange = () => {\n  const [visibilityChange, setVisibilityChange] = React.useState<boolean>(false)\n\n  const getHiddenProp = () => {\n    if (!document) {\n      return null\n    }\n    const prefixes = ['webkit', 'moz', 'ms', 'o']\n\n    // if 'hidden' is natively supported just return it\n    if ('hidden' in document) {\n      return 'hidden'\n    }\n\n    // otherwise loop over all the known prefixes until we find one\n    for (let i = 0; i < prefixes.length; i++) {\n      if (prefixes[i] + 'Hidden' in document) return prefixes[i] + 'Hidden'\n    }\n\n    // otherwise it's not supported\n    return null\n  }\n\n  const getVisibilityState = () => {\n    const prefixes = ['webkit', 'moz', 'ms', 'o']\n    if ('visibilityState' in document) return 'visibilityState'\n    for (let i = 0; i < prefixes.length; i++) {\n      if (prefixes[i] + 'VisibilityState' in document)\n        return prefixes[i] + 'VisibilityState'\n    }\n    // otherwise it's not supported\n    return null\n  }\n\n  useEffect(() => {\n    const eventName =\n      (getHiddenProp() ?? '').replace(/[H|h]idden/, '') + 'visibilitychange'\n    if (getHiddenProp()) {\n      document.addEventListener(\n        eventName,\n        function () {\n          setVisibilityChange(document[getVisibilityState() ?? ''] === visible)\n        },\n        false\n      )\n    }\n    return () => {\n      document.removeEventListener(eventName, function () {\n        setVisibilityChange(document[getVisibilityState() ?? ''] === visible)\n      })\n    }\n  }, [getHiddenProp()])\n\n  return { visibilityChange }\n}\n","import { DependencyList, useEffect, useMemo } from 'react'\nimport {\n  autoClear,\n  doRequest,\n  doRun,\n  getCacheRequest,\n  getMyConfig,\n  getPostBody,\n  getRequest,\n  getStoreCacheData,\n  handlePageBody,\n  setBody,\n  setStoreCacheData,\n  updateDefaultBody\n} from './utils'\nimport {\n  QueryConfig,\n  QueryHooksConfig,\n  QueryRunConfig,\n  QueryStoreType,\n  RequestResult,\n  RequestType,\n  UseResult,\n  ViewState\n} from './model'\nimport resso from 'resso'\nimport { useBrowserPageChange } from './hooks/browser-page-hooks'\n\nexport function createQueryStore<\n  R = Record<string, any> | string,\n  P = Record<string, any>\n>(request: RequestType<P> | string, config?: QueryConfig<R, P>) {\n  // 得到当前配置\n  let myConfig = getMyConfig<R, P>(config) as QueryConfig<R, P>\n\n  // 当前请求\n  let currentRequest: RequestResult | undefined\n\n  // 设置返回数据\n  function setResData(res: UseResult<R>) {\n    if (res.success) {\n      if (myConfig.isDefaultSet) {\n        store.setData(res.data)\n        store.total = res.total ?? 0\n      }\n      if (myConfig?.status && store?.status !== ViewState.error) {\n        store.isEmpty =\n          !res.data ||\n          (res.data && res.data instanceof Array && !res.data.length)\n      }\n      // 记录最后时间\n      store.lastRequestTime = new Date().getTime()\n\n      // 处理缓存\n      setStoreCacheData(myConfig, request, store, res)\n    } else if (!res.isCancel) {\n      store.error = { message: res.message, code: res.code, status: res.status }\n    }\n  }\n\n  // 创建store\n  const store = resso<QueryStoreType<R, P>>({\n    isBusy: false,\n    isError: false,\n    status: ViewState.idle,\n    isEmpty: undefined,\n    error: undefined,\n    setStatus: (status: ViewState) => {\n      store.status = status\n      store.isError = status === ViewState.error\n      store.isBusy = status === ViewState.busy\n    },\n    lastRequestTime: undefined,\n    body: undefined,\n    setBody: (inBody: Partial<P>, replace = false) => {\n      setBody<P>(store, inBody, replace)\n    },\n    current: 1,\n    pageSize: config?.pageSize ?? 10,\n    total: 0,\n    offset: undefined,\n    setPage: (config): Promise<UseResult<R>> => {\n      const { current, pageSize } = config ?? {}\n      if (current) {\n        store.current = current\n      }\n      if (pageSize) {\n        store.pageSize = pageSize\n      }\n      return store.run()\n    },\n    originData: undefined,\n    data: undefined,\n    setData: (data?: R) => {\n      store.data = data\n    },\n    refresh: (config): Promise<UseResult<R>> => {\n      myConfig = {\n        ...myConfig,\n        loading: false,\n        status: false,\n        ...(config ?? {}),\n        refresh: true\n      }\n      if (!currentRequest) {\n        return store.run(undefined, myConfig)\n      } else {\n        return doRequest<R, P>(currentRequest, store, myConfig, setResData)\n      }\n    },\n    run: doRun<R, P>(\n      (body?: Partial<P>, config?: QueryRunConfig): Promise<UseResult<R>> => {\n        myConfig = { ...myConfig, ...config }\n        // 清除\n        autoClear(store, myConfig.autoClear)\n\n        console.log(store)\n        // 获取缓存\n        const { cache, active } = getStoreCacheData<R, P>(\n          myConfig,\n          request,\n          store\n        )\n        // 如果有缓存 并且缓存有效\n        if (!config?.refresh && cache && active) {\n          return getCacheRequest<R, P>(myConfig, cache, store)\n        } else {\n          // 设置body\n          updateDefaultBody<P>(store, myConfig.defaultBody, body)\n          // 处理分页\n          let _body = handlePageBody(store, myConfig.usePage)\n          // 获取准备提交的请求体\n          _body = getPostBody(_body, myConfig.postBody)\n          // 获取请求体\n          currentRequest = getRequest(request, _body, myConfig.method)\n          // 发送请求\n          return doRequest<R, P>(currentRequest, store, myConfig, setResData)\n        }\n      },\n      myConfig\n    ),\n    cancel: (message?: string) => {\n      if (currentRequest) {\n        if (currentRequest.type === 'axios') {\n          // eslint-disable-next-line no-unused-expressions\n          currentRequest.source?.cancel(message)\n        }\n      }\n    },\n    clear: () => {\n      store.data = undefined\n      store.body = undefined\n      store.total = 0\n      store.current = 1\n      store.isEmpty = undefined\n    }\n  })\n  return store\n}\n\nexport function useQuery<\n  R = Record<string, any> | string,\n  P = Record<string, any>\n>(\n  request: RequestType<P> | string,\n  config?: QueryHooksConfig<R, P>,\n  deps?: DependencyList\n) {\n  const store = useMemo(() => createQueryStore(request, config), deps ?? [])\n  useEffect(() => {\n    const manual = config?.manual ?? false\n    if (!manual) {\n      store.run().then()\n    }\n    let interval: any\n    if (config?.pollingIntervalMs) {\n      if (interval) {\n        clearInterval(interval)\n      }\n      interval = setInterval(() => {\n        store.run().then()\n      }, config?.pollingIntervalMs)\n    }\n    return () => {\n      if (interval) {\n        clearInterval(interval)\n      }\n      store.cancel()\n    }\n  }, deps ?? [])\n\n  const { visibilityChange } = useBrowserPageChange()\n\n  useEffect(() => {\n    if (config?.refreshOnWindowFocus && visibilityChange) {\n      if (\n        !store.lastRequestTime ||\n        new Date().getTime() - store.lastRequestTime >\n          (config?.refreshOnWindowFocusTimespanMs ?? 0)\n      )\n        if (config?.refreshOnWindowFocusMode === 'run') {\n          store.run().then()\n        } else {\n          store.refresh().then()\n        }\n    }\n  }, [visibilityChange])\n  return store\n}\n","import { DependencyList, useEffect, useMemo } from 'react'\nimport {\n  autoClear,\n  doRequest,\n  doRun,\n  getCacheRequest,\n  getMyConfig,\n  getPostBody,\n  getRequest,\n  getStoreCacheData,\n  handlePageBody,\n  setBody,\n  setStoreCacheData,\n  updateDefaultBody\n} from './utils'\nimport {\n  QueryConfig,\n  QueryRunConfig,\n  RequestResult,\n  RequestType,\n  SubmitConfig,\n  SubmitHooksConfig,\n  SubmitStoreType,\n  UseResult,\n  ViewState\n} from './model'\nimport resso from 'resso'\nimport { useBrowserPageChange } from './hooks/browser-page-hooks'\n\nexport function createSubmitStore<\n  R = Record<string, any> | string,\n  P = Record<string, any>\n>(request: RequestType<P> | string, config?: SubmitConfig<R, P>) {\n  // 得到当前配置\n  let myConfig = getMyConfig<R, P>(config) as QueryConfig<R, P>\n\n  // 当前请求\n  let currentRequest: RequestResult\n\n  // 设置返回数据\n  function setResData(res: UseResult<R>) {\n    if (res.success) {\n      if (myConfig.isDefaultSet) {\n        store.setData(res.data)\n      }\n      if (myConfig?.status && store?.status !== ViewState.error) {\n        store.isEmpty =\n          !res.data ||\n          (res.data && res.data instanceof Array && !res.data.length)\n      }\n      // 记录最后时间\n      store.lastRequestTime = new Date().getTime()\n\n      // 处理缓存\n      setStoreCacheData(myConfig, request, store, res)\n    } else if (!res.isCancel) {\n      store.error = { message: res.message, code: res.code, status: res.status }\n    }\n  }\n\n  // 创建store\n  const store = resso<SubmitStoreType<R, P>>({\n    isBusy: false,\n    isError: false,\n    status: ViewState.idle,\n    isEmpty: undefined,\n    error: undefined,\n    setStatus: (status: ViewState) => {\n      store.status = status\n      store.isError = status === ViewState.error\n      store.isBusy = status === ViewState.busy\n    },\n    lastRequestTime: undefined,\n    body: undefined,\n    setBody: (inBody: Partial<P>, replace = false) => {\n      setBody<P>(store, inBody, replace)\n    },\n    originData: undefined,\n    data: undefined,\n    setData: (data?: R) => {\n      store.data = data\n    },\n    refresh: (config): Promise<UseResult<R>> => {\n      myConfig = {\n        ...myConfig,\n        loading: false,\n        status: false,\n        ...(config ?? {}),\n        refresh: true\n      }\n      if (!currentRequest) {\n        return store.run(undefined, myConfig)\n      } else {\n        return doRequest<R, P>(currentRequest, store, myConfig, setResData)\n      }\n    },\n    run: doRun<R, P>(\n      (body?: Partial<P>, config?: QueryRunConfig): Promise<UseResult<R>> => {\n        myConfig = { ...myConfig, ...config }\n        // 清除\n        autoClear(store, myConfig.autoClear)\n        // 获取缓存\n        const { cache, active } = getStoreCacheData<R, P>(\n          myConfig,\n          request,\n          store\n        )\n        // 如果有缓存 并且缓存有效\n        if (!config?.refresh && cache && active) {\n          return getCacheRequest<R, P>(myConfig, cache, store)\n        } else {\n          // 设置body\n          updateDefaultBody<P>(store, myConfig.defaultBody, body)\n          // 处理分页\n          let _body = handlePageBody(store, myConfig.usePage)\n          // 获取准备提交的请求体\n          _body = getPostBody(_body, myConfig.postBody)\n          // 获取请求体\n          currentRequest = getRequest(request, _body, myConfig.method)\n          // 发送请求\n          return doRequest<R, P>(currentRequest, store, myConfig, setResData)\n        }\n      },\n      myConfig\n    ),\n    cancel: (message?: string) => {\n      if (currentRequest) {\n        if (currentRequest.type === 'axios') {\n          // eslint-disable-next-line no-unused-expressions\n          currentRequest.source?.cancel(message)\n        }\n      }\n    },\n    clear: () => {\n      store.data = undefined\n      store.body = undefined\n      store.isEmpty = undefined\n    }\n  })\n  return store\n}\n\nexport function useSubmit<\n  R = Record<string, any> | string,\n  P = Record<string, any>\n>(\n  request: RequestType<P> | string,\n  config?: SubmitHooksConfig<R, P>,\n  deps?: DependencyList\n) {\n  const store = useMemo(() => createSubmitStore(request, config), deps ?? [])\n  useEffect(() => {\n    const manual = config?.manual ?? true\n    if (!manual) {\n      store.run().then()\n    }\n    let interval: any\n    if (config?.pollingIntervalMs) {\n      if (interval) {\n        clearInterval(interval)\n      }\n      interval = setInterval(() => {\n        store.run().then()\n      }, config?.pollingIntervalMs)\n    }\n    return () => {\n      if (interval) {\n        clearInterval(interval)\n      }\n      store.cancel()\n    }\n  }, deps ?? [])\n\n  const { visibilityChange } = useBrowserPageChange()\n\n  useEffect(() => {\n    if (config?.refreshOnWindowFocus && visibilityChange) {\n      if (\n        !store.lastRequestTime ||\n        new Date().getTime() - store.lastRequestTime >\n          (config?.refreshOnWindowFocusTimespanMs ?? 0)\n      )\n        if (config?.refreshOnWindowFocusMode === 'run') {\n          store.run().then()\n        } else {\n          store.refresh().then()\n        }\n    }\n  }, [visibilityChange])\n  return store\n}\n"]},"metadata":{},"sourceType":"module"}