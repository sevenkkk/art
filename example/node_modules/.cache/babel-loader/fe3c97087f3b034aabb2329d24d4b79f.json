{"ast":null,"code":"import React, { useEffect, useMemo } from 'react';\nimport resso from 'resso';\nexport { default as resso } from 'resso';\nfunction _extends() {\n  _extends = Object.assign ? Object.assign.bind() : function (target) {\n    for (var i = 1; i < arguments.length; i++) {\n      var source = arguments[i];\n      for (var key in source) {\n        if (Object.prototype.hasOwnProperty.call(source, key)) {\n          target[key] = source[key];\n        }\n      }\n    }\n    return target;\n  };\n  return _extends.apply(this, arguments);\n}\nvar Art = /*#__PURE__*/function () {\n  function Art() {}\n  Art.setup = function setup(config) {\n    if (config) {\n      this.config = _extends({}, this.config, config);\n      if (this.config.axios) {\n        this.axios = this.config.axios.create({\n          baseURL: this.config.baseURL\n        });\n      }\n    }\n  };\n  return Art;\n}();\nArt.config = {\n  showErrorMessage: function showErrorMessage(res) {\n    console.log(res);\n  },\n  showSuccessMessage: function showSuccessMessage(res) {\n    console.log(res);\n  },\n  handlePage: function handlePage(page, pageSize) {\n    return {\n      page: page,\n      pageSize: pageSize\n    };\n  },\n  handleHttpResult: function handleHttpResult(resBody) {\n    var _ref = resBody || {},\n      success = _ref.success,\n      errorCode = _ref.errorCode,\n      errorMessage = _ref.errorMessage,\n      payload = _ref.payload,\n      count = _ref.count;\n    return {\n      success: success,\n      code: errorCode,\n      message: errorMessage,\n      data: payload,\n      total: count\n    };\n  }\n};\n\n// A type of promise-like that resolves synchronously and supports only one observer\n\nconst _iteratorSymbol = /*#__PURE__*/typeof Symbol !== \"undefined\" ? Symbol.iterator || (Symbol.iterator = Symbol(\"Symbol.iterator\")) : \"@@iterator\";\nconst _asyncIteratorSymbol = /*#__PURE__*/typeof Symbol !== \"undefined\" ? Symbol.asyncIterator || (Symbol.asyncIterator = Symbol(\"Symbol.asyncIterator\")) : \"@@asyncIterator\";\n\n// Asynchronously call a function and send errors to recovery continuation\nfunction _catch(body, recover) {\n  try {\n    var result = body();\n  } catch (e) {\n    return recover(e);\n  }\n  if (result && result.then) {\n    return result.then(void 0, recover);\n  }\n  return result;\n}\nvar ViewState;\n(function (ViewState) {\n  ViewState[ViewState[\"idle\"] = 0] = \"idle\";\n  ViewState[ViewState[\"busy\"] = 1] = \"busy\";\n  ViewState[ViewState[\"error\"] = 2] = \"error\";\n})(ViewState || (ViewState = {}));\nvar dataCache = new Map();\nfunction createCacheKey(key, ids) {\n  var prefix = 'key';\n  return prefix + \"_\" + key + (ids === null || ids === void 0 ? void 0 : ids.map(function (id) {\n    return \"_\" + id;\n  }));\n}\nfunction setCache(key, data) {\n  dataCache.set(key, data);\n}\nfunction getCache(key) {\n  return dataCache.get(key);\n}\nfunction clearCache(key) {\n  dataCache[\"delete\"](key);\n}\nfunction getAxiosRequest(method, url, body, config) {\n  switch (method) {\n    case 'POST':\n    case 'post':\n      return Art.axios.post(url, body, config);\n    case 'PUT':\n    case 'put':\n      return Art.axios.put(url, body, config);\n    case 'DELETE':\n    case 'delete':\n      return Art.axios[\"delete\"](url, config);\n    default:\n      return Art.axios.get(url, config);\n  }\n}\nfunction handleError(e) {\n  if (Art.config.axios.isCancel(e)) {\n    return {\n      success: false,\n      isCancel: true,\n      message: e.message\n    };\n  } else {\n    var response = e.response;\n    if (response) {\n      var axiosRes = e;\n      if (Art.config.handleHttpErrorResult) {\n        return _extends({\n          message: axiosRes.message\n        }, Art.config.handleHttpErrorResult(response), {\n          success: false,\n          status: response.status,\n          isCancel: false\n        });\n      } else {\n        return {\n          success: false,\n          status: response.status,\n          code: axiosRes.code,\n          message: axiosRes.message,\n          isCancel: false\n        };\n      }\n    } else {\n      throw new Error(e);\n    }\n  }\n}\nvar doRequest = function doRequest(request, store, config, setData) {\n  try {\n    var _temp4 = function _temp4() {\n      setData(myRes);\n      handleCallback(config, myRes);\n      handleMessage(config, myRes);\n      handleEndLoading(config);\n      return myRes;\n    };\n    handleStartLoading(config);\n    var setStatus = function setStatus(status) {\n      try {\n        var loadingWait = function loadingWait() {\n          try {\n            var _temp9 = function () {\n              if (status !== ViewState.busy && config.loadingDelayMs) {\n                return Promise.resolve(waitTime(config.loadingDelayMs)).then(function () {});\n              }\n            }();\n            return Promise.resolve(_temp9 && _temp9.then ? _temp9.then(function () {}) : void 0);\n          } catch (e) {\n            return Promise.reject(e);\n          }\n        };\n        var _temp7 = function () {\n          if (config !== null && config !== void 0 && config.status) {\n            return Promise.resolve(loadingWait()).then(function () {\n              store.setStatus(status);\n            });\n          }\n        }();\n        return Promise.resolve(_temp7 && _temp7.then ? _temp7.then(function () {}) : void 0);\n      } catch (e) {\n        return Promise.reject(e);\n      }\n    };\n    var myRes;\n    var _temp5 = _catch(function () {\n      return Promise.resolve(setStatus(ViewState.busy)).then(function () {\n        return Promise.resolve(request.request()).then(function (res) {\n          myRes = config.handleHttpResult ? config.handleHttpResult(res) : Art.config.handleHttpResult ? Art.config.handleHttpResult(res) : res;\n          store.originData = myRes.data;\n          if (config.postData) {\n            myRes.data = config.postData(myRes.data);\n          }\n          return Promise.resolve(setStatus(ViewState.idle)).then(function () {});\n        });\n      });\n    }, function (e) {\n      myRes = handleRequestCatch(e, request);\n      var _temp = function () {\n        if (!myRes.isCancel) {\n          return Promise.resolve(setStatus(ViewState.error)).then(function () {});\n        } else {\n          return Promise.resolve(setStatus(ViewState.idle)).then(function () {});\n        }\n      }();\n      return _temp && _temp.then ? _temp.then(function () {}) : void 0;\n    });\n    return Promise.resolve(_temp5 && _temp5.then ? _temp5.then(_temp4) : _temp4(_temp5));\n  } catch (e) {\n    return Promise.reject(e);\n  }\n};\nfunction updateDefaultBody(store, defaultBody, body) {\n  var _body;\n  if (defaultBody) {\n    var _defaultBody;\n    if (typeof defaultBody === 'function') {\n      _defaultBody = defaultBody();\n    } else {\n      _defaultBody = defaultBody;\n    }\n    _body = _extends({}, _defaultBody, body != null ? body : {});\n  } else {\n    _body = body;\n  }\n  store.body = _body;\n}\nfunction handlePageBody(store, usePage) {\n  var _body = store.body;\n  if (usePage) {\n    var _store = store;\n    if (Art.config.handlePage) {\n      var _body2;\n      _body = _extends({}, (_body2 = _body) != null ? _body2 : {}, Art.config.handlePage(_store.current, _store.pageSize));\n    } else {\n      var _body3;\n      _body = _extends({}, (_body3 = _body) != null ? _body3 : {}, {\n        current: _store.current,\n        pageSize: _store.pageSize\n      });\n    }\n  }\n  return _body;\n}\nfunction getPostBody(body, postBody) {\n  var _body = body;\n  if (postBody && _body) {\n    _body = postBody(_body);\n  }\n  return _body;\n}\nfunction autoClear(store, autoClear) {\n  if (autoClear) {\n    store.clear();\n  }\n}\nfunction getMyConfig(config) {\n  var defaultConfig = {\n    status: true,\n    loading: false,\n    isDefaultSet: true,\n    autoClear: false,\n    cacheTime: 300000,\n    staleTime: 0,\n    showMessage: true,\n    showSuccessMessage: false,\n    showErrorMessage: true\n  };\n  return _extends({}, defaultConfig, config != null ? config : {});\n}\nfunction handleStartLoading(config) {\n  if (config.loading && config.startLoading) {\n    config.startLoading();\n  }\n}\nfunction handleEndLoading(config) {\n  if (config.loading && config.startLoading) {\n    config.startLoading();\n  }\n}\nfunction handleMessage(config, res) {\n  if (config.showMessage) {\n    if (res.success && config.showSuccessMessage && Art.config.showSuccessMessage) {\n      Art.config.showSuccessMessage(res);\n    } else if (!res.success && config.showErrorMessage && Art.config.showErrorMessage) {\n      Art.config.showErrorMessage(res);\n    }\n  }\n}\nfunction handleCallback(config, res) {\n  if (res.success) {\n    if (config.successCallback) {\n      config.successCallback(res, false);\n    }\n  } else if (!res.isCancel) {\n    if (config.failCallback) {\n      config.failCallback(res);\n    }\n  }\n  if (config.onLoadComplete) {\n    config.onLoadComplete(res);\n  }\n}\nfunction handleRequestCatch(e, request) {\n  var result = {\n    success: false,\n    isCancel: false,\n    message: e\n  };\n  if (request.type === 'axios') {\n    result = handleError(e);\n  }\n  if (Art.config.handleHttpError) {\n    Art.config.handleHttpError(e);\n  }\n  console.log(e);\n  return result;\n}\nfunction getRequest(request, body, method) {\n  var _request;\n  var source;\n  if (typeof request === 'function') {\n    _request = function _request() {\n      return request(body);\n    };\n  } else {\n    var url = request;\n    var isPathParams = url.includes('{') && url.includes('}');\n    var _method = method != null ? method : isPathParams ? 'GET' : body ? 'POST' : 'GET';\n    var isPost = method === 'POST' || method === 'post';\n    if (body && typeof body === 'object' && isPathParams) {\n      Object.keys(body).forEach(function (key) {\n        url = url.replace(new RegExp('\\\\{' + key + '\\\\}', 'g'), body[key]);\n      });\n    }\n    if (Art.config.axios != null) {\n      source = Art.config.axios.CancelToken.source();\n      _request = function _request() {\n        return getAxiosRequest(_method, url, body != null ? body : isPost ? {} : undefined, {\n          cancelToken: source.token\n        });\n      };\n    } else {\n      throw new Error('Coco 必须实例化 http 组件，目前支持axios');\n    }\n  }\n  return {\n    request: _request,\n    type: 'axios',\n    source: source\n  };\n}\nfunction setBody(store, inBody, replace) {\n  if (replace === void 0) {\n    replace = false;\n  }\n  var body = store.body;\n  if (body && !replace) {\n    store.body = _extends({}, inBody, store.body);\n  } else {\n    store.body = inBody;\n  }\n}\nvar waitTime = function waitTime(time) {\n  if (time === void 0) {\n    time = 100;\n  }\n  return new Promise(function (resolve) {\n    setTimeout(function () {\n      resolve(true);\n    }, time);\n  });\n};\nfunction doRun(request, config) {\n  if (config.throttleMs) {\n    return throttle(request, config.throttleMs);\n  }\n  return debounce(request, config.debounceMs);\n}\nfunction debounce(request, ms) {\n  var timeout;\n  return function (body, config) {\n    clearTimeout(timeout);\n    return new Promise(function (resolve) {\n      if (ms) {\n        timeout = setTimeout(function () {\n          resolve(request(body, config));\n        }, ms);\n      } else {\n        resolve(request(body, config));\n      }\n    });\n  };\n}\nfunction throttle(request, waitMs) {\n  var timeout;\n  var old = 0;\n  return function (body, config) {\n    return new Promise(function (resolve) {\n      var now = new Date().valueOf();\n      if (!old) {\n        old = now;\n      }\n      if (now - old > waitMs) {\n        if (timeout) {\n          clearTimeout(timeout);\n          timeout = null;\n        }\n        resolve(request(body, config));\n        old = now;\n      } else if (!timeout) {\n        timeout = setTimeout(function () {\n          old = new Date().valueOf();\n          timeout = null;\n          resolve(request(body, config));\n        }, waitMs);\n      }\n    });\n  };\n}\nfunction setStoreCacheData(config, request, store, res) {\n  if (!config.cache) {\n    return;\n  }\n  var key = getCacheKey(config, request, store);\n  var pagination;\n  try {\n    if (config.usePage) {\n      var current = store.current,\n        pageSize = store.pageSize,\n        total = store.total,\n        offset = store.offset;\n      pagination = {\n        current: current,\n        pageSize: pageSize,\n        total: total,\n        offset: offset\n      };\n    }\n  } catch (e) {}\n  setCache(key, {\n    body: store.body,\n    data: res,\n    time: new Date().getTime(),\n    pagination: pagination\n  });\n}\nfunction getStoreCacheData(config, request, store) {\n  if (!config.cache) {\n    return {\n      cache: undefined,\n      active: false\n    };\n  }\n  var key = getCacheKey(config, request, store);\n  var cache = getCache(key);\n  if (cache) {\n    var _config$cacheTime;\n    var cacheTime = (_config$cacheTime = config.cacheTime) != null ? _config$cacheTime : 300000;\n    if (cacheTime < 0 || new Date().getTime() - cache.time <= cacheTime) {\n      return {\n        cache: cache,\n        active: true\n      };\n    } else {\n      clearCache(key);\n    }\n  }\n  return {\n    cache: undefined,\n    active: false\n  };\n}\nfunction getCacheRequest(config, cache, store) {\n  var _config$staleTime;\n  var res = cache.data;\n  if (config.successCallback) {\n    config.successCallback(res, true);\n  }\n  if (cache.pagination) {\n    try {\n      var _store = store;\n      var _cache$pagination = cache.pagination,\n        current = _cache$pagination.current,\n        pageSize = _cache$pagination.pageSize,\n        total = _cache$pagination.total,\n        offset = _cache$pagination.offset;\n      _store.current = current;\n      _store.pageSize = pageSize;\n      _store.total = total;\n      _store.offset = offset;\n    } catch (e) {}\n  }\n  store.data = cache.data.data;\n  store.body = cache.body;\n  var staleTime = (_config$staleTime = config.staleTime) != null ? _config$staleTime : 0;\n  if (staleTime >= 0 && new Date().getTime() - cache.time > staleTime) {\n    store.refresh().then();\n  }\n  return new Promise(function (resolve) {\n    return resolve(res);\n  });\n}\nfunction getCacheKey(config, request, store) {\n  var key;\n  if (config.cache === true || typeof config.cache === 'function') {\n    if (typeof request === 'function') {\n      throw new Error('request是url的形式的时候，cache只能是字符串');\n    }\n  }\n  if (typeof config.cache === 'string') {\n    key = createCacheKey(config.cache);\n  } else if (typeof config.cache === 'function') {\n    var ids = config.cache(store.body);\n    key = createCacheKey(request, ids);\n  } else {\n    key = createCacheKey(request);\n  }\n  if (config.usePage) {\n    var current = store.current,\n      pageSize = store.pageSize,\n      offset = store.offset;\n    return key + \"_\" + current + \"_\" + pageSize + offset ? \"'_\" + offset + \"'\" : '';\n  }\n  return key;\n}\nvar document = window ? window.document : undefined;\nvar visible = 'visible';\nvar useBrowserPageChange = function useBrowserPageChange() {\n  var _React$useState = React.useState(false),\n    visibilityChange = _React$useState[0],\n    setVisibilityChange = _React$useState[1];\n  var getHiddenProp = function getHiddenProp() {\n    if (!document) {\n      return null;\n    }\n    var prefixes = ['webkit', 'moz', 'ms', 'o'];\n    if ('hidden' in document) {\n      return 'hidden';\n    }\n    for (var i = 0; i < prefixes.length; i++) {\n      if (prefixes[i] + 'Hidden' in document) return prefixes[i] + 'Hidden';\n    }\n    return null;\n  };\n  var getVisibilityState = function getVisibilityState() {\n    var prefixes = ['webkit', 'moz', 'ms', 'o'];\n    if ('visibilityState' in document) return 'visibilityState';\n    for (var i = 0; i < prefixes.length; i++) {\n      if (prefixes[i] + 'VisibilityState' in document) return prefixes[i] + 'VisibilityState';\n    }\n    return null;\n  };\n  useEffect(function () {\n    var _getHiddenProp;\n    var eventName = ((_getHiddenProp = getHiddenProp()) != null ? _getHiddenProp : '').replace(/[H|h]idden/, '') + 'visibilitychange';\n    if (getHiddenProp()) {\n      document.addEventListener(eventName, function () {\n        var _getVisibilityState;\n        setVisibilityChange(document[(_getVisibilityState = getVisibilityState()) != null ? _getVisibilityState : ''] === visible);\n      }, false);\n    }\n    return function () {\n      document.removeEventListener(eventName, function () {\n        var _getVisibilityState2;\n        setVisibilityChange(document[(_getVisibilityState2 = getVisibilityState()) != null ? _getVisibilityState2 : ''] === visible);\n      });\n    };\n  }, [getHiddenProp()]);\n  return {\n    visibilityChange: visibilityChange\n  };\n};\nfunction createQueryStore(request, config) {\n  var _config$pageSize;\n  var myConfig = getMyConfig(config);\n  var currentRequest;\n  function setResData(res) {\n    if (res.success) {\n      var _myConfig;\n      if (myConfig.isDefaultSet) {\n        var _res$total;\n        store.setData(res.data);\n        store.total = (_res$total = res.total) != null ? _res$total : 0;\n      }\n      if ((_myConfig = myConfig) !== null && _myConfig !== void 0 && _myConfig.status && (store === null || store === void 0 ? void 0 : store.status) !== ViewState.error) {\n        store.isEmpty = !res.data || res.data && res.data instanceof Array && !res.data.length;\n      }\n      store.lastRequestTime = new Date().getTime();\n      setStoreCacheData(myConfig, request, store, res);\n    } else if (!res.isCancel) {\n      store.error = {\n        message: res.message,\n        code: res.code,\n        status: res.status\n      };\n    }\n  }\n  var store = resso({\n    isBusy: false,\n    isError: false,\n    status: ViewState.idle,\n    isEmpty: undefined,\n    error: undefined,\n    setStatus: function setStatus(status) {\n      store.status = status;\n      store.isError = status === ViewState.error;\n      store.isBusy = status === ViewState.busy;\n    },\n    lastRequestTime: undefined,\n    body: undefined,\n    setBody: function setBody$1(inBody, replace) {\n      if (replace === void 0) {\n        replace = false;\n      }\n      setBody(store, inBody, replace);\n    },\n    current: 1,\n    pageSize: (_config$pageSize = config === null || config === void 0 ? void 0 : config.pageSize) != null ? _config$pageSize : 10,\n    total: 0,\n    offset: undefined,\n    setPage: function setPage(config) {\n      var _ref = config != null ? config : {},\n        current = _ref.current,\n        pageSize = _ref.pageSize;\n      if (current) {\n        store.current = current;\n      }\n      if (pageSize) {\n        store.pageSize = pageSize;\n      }\n      return store.run();\n    },\n    originData: undefined,\n    data: undefined,\n    setData: function setData(data) {\n      store.data = data;\n    },\n    refresh: function refresh(config) {\n      myConfig = _extends({}, myConfig, {\n        loading: false,\n        status: false\n      }, config != null ? config : {}, {\n        refresh: true\n      });\n      if (!currentRequest) {\n        return store.run(undefined, myConfig);\n      } else {\n        return doRequest(currentRequest, store, myConfig, setResData);\n      }\n    },\n    run: doRun(function (body, config) {\n      myConfig = _extends({}, myConfig, config);\n      autoClear(store, myConfig.autoClear);\n      console.log(store);\n      var _getStoreCacheData = getStoreCacheData(myConfig, request, store),\n        cache = _getStoreCacheData.cache,\n        active = _getStoreCacheData.active;\n      if (!(config !== null && config !== void 0 && config.refresh) && cache && active) {\n        return getCacheRequest(myConfig, cache, store);\n      } else {\n        updateDefaultBody(store, myConfig.defaultBody, body);\n        var _body = handlePageBody(store, myConfig.usePage);\n        _body = getPostBody(_body, myConfig.postBody);\n        currentRequest = getRequest(request, _body, myConfig.method);\n        return doRequest(currentRequest, store, myConfig, setResData);\n      }\n    }, myConfig),\n    cancel: function cancel(message) {\n      if (currentRequest) {\n        if (currentRequest.type === 'axios') {\n          var _currentRequest$sourc;\n          (_currentRequest$sourc = currentRequest.source) === null || _currentRequest$sourc === void 0 ? void 0 : _currentRequest$sourc.cancel(message);\n        }\n      }\n    },\n    clear: function clear() {\n      store.data = undefined;\n      store.body = undefined;\n      store.total = 0;\n      store.current = 1;\n      store.isEmpty = undefined;\n    }\n  });\n  return store;\n}\nfunction useQuery(request, config, deps) {\n  var store = useMemo(function () {\n    return createQueryStore(request, config);\n  }, deps != null ? deps : []);\n  useEffect(function () {\n    var _config$manual;\n    var manual = (_config$manual = config === null || config === void 0 ? void 0 : config.manual) != null ? _config$manual : false;\n    if (!manual) {\n      store.run().then();\n    }\n    var interval;\n    if (config !== null && config !== void 0 && config.pollingIntervalMs) {\n      if (interval) {\n        clearInterval(interval);\n      }\n      interval = setInterval(function () {\n        store.run().then();\n      }, config === null || config === void 0 ? void 0 : config.pollingIntervalMs);\n    }\n    return function () {\n      if (interval) {\n        clearInterval(interval);\n      }\n      store.cancel();\n    };\n  }, deps != null ? deps : []);\n  var _useBrowserPageChange = useBrowserPageChange(),\n    visibilityChange = _useBrowserPageChange.visibilityChange;\n  useEffect(function () {\n    if (config !== null && config !== void 0 && config.refreshOnWindowFocus && visibilityChange) {\n      var _config$refreshOnWind;\n      if (!store.lastRequestTime || new Date().getTime() - store.lastRequestTime > ((_config$refreshOnWind = config === null || config === void 0 ? void 0 : config.refreshOnWindowFocusTimespanMs) != null ? _config$refreshOnWind : 0)) if ((config === null || config === void 0 ? void 0 : config.refreshOnWindowFocusMode) === 'run') {\n        store.run().then();\n      } else {\n        store.refresh().then();\n      }\n    }\n  }, [visibilityChange]);\n  return store;\n}\nfunction createSubmitStore(request, config) {\n  var myConfig = getMyConfig(config);\n  var currentRequest;\n  function setResData(res) {\n    if (res.success) {\n      var _myConfig;\n      if (myConfig.isDefaultSet) {\n        store.setData(res.data);\n      }\n      if ((_myConfig = myConfig) !== null && _myConfig !== void 0 && _myConfig.status && (store === null || store === void 0 ? void 0 : store.status) !== ViewState.error) {\n        store.isEmpty = !res.data || res.data && res.data instanceof Array && !res.data.length;\n      }\n      store.lastRequestTime = new Date().getTime();\n      setStoreCacheData(myConfig, request, store, res);\n    } else if (!res.isCancel) {\n      store.error = {\n        message: res.message,\n        code: res.code,\n        status: res.status\n      };\n    }\n  }\n  var store = resso({\n    isBusy: false,\n    isError: false,\n    status: ViewState.idle,\n    isEmpty: undefined,\n    error: undefined,\n    setStatus: function setStatus(status) {\n      store.status = status;\n      store.isError = status === ViewState.error;\n      store.isBusy = status === ViewState.busy;\n    },\n    lastRequestTime: undefined,\n    body: undefined,\n    setBody: function setBody$1(inBody, replace) {\n      if (replace === void 0) {\n        replace = false;\n      }\n      setBody(store, inBody, replace);\n    },\n    originData: undefined,\n    data: undefined,\n    setData: function setData(data) {\n      store.data = data;\n    },\n    refresh: function refresh(config) {\n      myConfig = _extends({}, myConfig, {\n        loading: false,\n        status: false\n      }, config != null ? config : {}, {\n        refresh: true\n      });\n      if (!currentRequest) {\n        return store.run(undefined, myConfig);\n      } else {\n        return doRequest(currentRequest, store, myConfig, setResData);\n      }\n    },\n    run: doRun(function (body, config) {\n      myConfig = _extends({}, myConfig, config);\n      autoClear(store, myConfig.autoClear);\n      var _getStoreCacheData = getStoreCacheData(myConfig, request, store),\n        cache = _getStoreCacheData.cache,\n        active = _getStoreCacheData.active;\n      if (!(config !== null && config !== void 0 && config.refresh) && cache && active) {\n        return getCacheRequest(myConfig, cache, store);\n      } else {\n        updateDefaultBody(store, myConfig.defaultBody, body);\n        var _body = handlePageBody(store, myConfig.usePage);\n        _body = getPostBody(_body, myConfig.postBody);\n        currentRequest = getRequest(request, _body, myConfig.method);\n        return doRequest(currentRequest, store, myConfig, setResData);\n      }\n    }, myConfig),\n    cancel: function cancel(message) {\n      if (currentRequest) {\n        if (currentRequest.type === 'axios') {\n          var _currentRequest$sourc;\n          (_currentRequest$sourc = currentRequest.source) === null || _currentRequest$sourc === void 0 ? void 0 : _currentRequest$sourc.cancel(message);\n        }\n      }\n    },\n    clear: function clear() {\n      store.data = undefined;\n      store.body = undefined;\n      store.isEmpty = undefined;\n    }\n  });\n  return store;\n}\nfunction useSubmit(request, config, deps) {\n  var store = useMemo(function () {\n    return createSubmitStore(request, config);\n  }, deps != null ? deps : []);\n  useEffect(function () {\n    var _config$manual;\n    var manual = (_config$manual = config === null || config === void 0 ? void 0 : config.manual) != null ? _config$manual : true;\n    if (!manual) {\n      store.run().then();\n    }\n    var interval;\n    if (config !== null && config !== void 0 && config.pollingIntervalMs) {\n      if (interval) {\n        clearInterval(interval);\n      }\n      interval = setInterval(function () {\n        store.run().then();\n      }, config === null || config === void 0 ? void 0 : config.pollingIntervalMs);\n    }\n    return function () {\n      if (interval) {\n        clearInterval(interval);\n      }\n      store.cancel();\n    };\n  }, deps != null ? deps : []);\n  var _useBrowserPageChange = useBrowserPageChange(),\n    visibilityChange = _useBrowserPageChange.visibilityChange;\n  useEffect(function () {\n    if (config !== null && config !== void 0 && config.refreshOnWindowFocus && visibilityChange) {\n      var _config$refreshOnWind;\n      if (!store.lastRequestTime || new Date().getTime() - store.lastRequestTime > ((_config$refreshOnWind = config === null || config === void 0 ? void 0 : config.refreshOnWindowFocusTimespanMs) != null ? _config$refreshOnWind : 0)) if ((config === null || config === void 0 ? void 0 : config.refreshOnWindowFocusMode) === 'run') {\n        store.run().then();\n      } else {\n        store.refresh().then();\n      }\n    }\n  }, [visibilityChange]);\n  return store;\n}\nexport { Art, ViewState, createQueryStore, createSubmitStore, useQuery, useSubmit };","map":{"version":3,"mappings":"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","names":["Art","setup","config","axios","create","baseURL","showErrorMessage","res","console","log","showSuccessMessage","handlePage","page","pageSize","handleHttpResult","resBody","success","errorCode","errorMessage","payload","count","code","message","data","total","_iteratorSymbol","Symbol","iterator","_asyncIteratorSymbol","asyncIterator","_catch","body","recover","result","e","then","ViewState","dataCache","Map","createCacheKey","key","ids","prefix","map","id","setCache","set","getCache","get","clearCache","getAxiosRequest","method","url","post","put","handleError","isCancel","response","axiosRes","handleHttpErrorResult","status","Error","doRequest","request","store","setData","myRes","handleCallback","handleMessage","handleEndLoading","handleStartLoading","setStatus","loadingWait","busy","loadingDelayMs","waitTime","originData","postData","idle","handleRequestCatch","error","updateDefaultBody","defaultBody","_body","_defaultBody","handlePageBody","usePage","_store","current","getPostBody","postBody","autoClear","clear","getMyConfig","defaultConfig","loading","isDefaultSet","cacheTime","staleTime","showMessage","startLoading","successCallback","failCallback","onLoadComplete","type","handleHttpError","getRequest","_request","source","isPathParams","includes","_method","isPost","Object","keys","forEach","replace","RegExp","CancelToken","undefined","cancelToken","token","setBody","inBody","time","Promise","resolve","setTimeout","doRun","throttleMs","throttle","debounce","debounceMs","ms","timeout","clearTimeout","waitMs","old","now","Date","valueOf","setStoreCacheData","cache","getCacheKey","pagination","offset","getTime","getStoreCacheData","active","getCacheRequest","refresh","document","window","visible","useBrowserPageChange","React","useState","visibilityChange","setVisibilityChange","getHiddenProp","prefixes","i","length","getVisibilityState","useEffect","eventName","addEventListener","removeEventListener","createQueryStore","myConfig","currentRequest","setResData","_myConfig","isEmpty","Array","lastRequestTime","resso","isBusy","isError","setPage","run","cancel","_currentRequest$sourc","useQuery","deps","useMemo","manual","interval","pollingIntervalMs","clearInterval","setInterval","refreshOnWindowFocus","refreshOnWindowFocusTimespanMs","refreshOnWindowFocusMode","createSubmitStore","useSubmit"],"sources":["../src/lib/art.ts","../node_modules/babel-plugin-transform-async-to-promises/helpers.mjs","../src/lib/model.ts","../src/lib/cache.ts","../src/lib/axios/index.ts","../src/lib/utils.ts","../src/lib/hooks/browser-page-hooks.tsx","../src/lib/query.ts","../src/lib/submit.ts"],"sourcesContent":["import { UseResult } from './model'\nimport { AxiosInstance, AxiosStatic } from './axios/axios'\n\nexport interface TemplateConfigOptions {\n  baseURL?: string\n  axios?: AxiosStatic | any\n  showErrorMessage?: (res: UseResult) => void\n  showSuccessMessage?: (res: UseResult) => void\n  startLoading?: () => void\n  endLoading?: () => void\n  handleHttpResult?: (res: any) => UseResult\n  handleHttpErrorResult?: (resError: any) => UseResult\n  handlePage?: (current: number, pageSize: number) => any\n  handleHttpError?: <T>(resError: T) => void\n}\n\nexport class Art {\n  static axios?: AxiosInstance\n\n  // Default global configuration\n  static config: TemplateConfigOptions = {\n    showErrorMessage: (res) => {\n      console.log(res)\n    },\n    showSuccessMessage: (res) => {\n      console.log(res)\n    },\n    handlePage: (page, pageSize) => {\n      return { page, pageSize }\n    },\n    handleHttpResult: (resBody: any): UseResult<any> => {\n      const { success, errorCode, errorMessage, payload, count } = resBody || {}\n      return {\n        success,\n        code: errorCode,\n        message: errorMessage,\n        data: payload,\n        total: count\n      }\n    }\n  }\n\n  /**\n   * Set global configuration\n   * @param config\n   */\n  static setup(config?: TemplateConfigOptions): void {\n    if (config) {\n      this.config = { ...this.config, ...config }\n      if (this.config.axios) {\n        this.axios = this.config.axios.create({ baseURL: this.config.baseURL })\n      }\n    }\n  }\n}\n","// A type of promise-like that resolves synchronously and supports only one observer\nexport const _Pact = /*#__PURE__*/(function() {\n\tfunction _Pact() {}\n\t_Pact.prototype.then = function(onFulfilled, onRejected) {\n\t\tconst result = new _Pact();\n\t\tconst state = this.s;\n\t\tif (state) {\n\t\t\tconst callback = state & 1 ? onFulfilled : onRejected;\n\t\t\tif (callback) {\n\t\t\t\ttry {\n\t\t\t\t\t_settle(result, 1, callback(this.v));\n\t\t\t\t} catch (e) {\n\t\t\t\t\t_settle(result, 2, e);\n\t\t\t\t}\n\t\t\t\treturn result;\n\t\t\t} else {\n\t\t\t\treturn this;\n\t\t\t}\n\t\t}\n\t\tthis.o = function(_this) {\n\t\t\ttry {\n\t\t\t\tconst value = _this.v;\n\t\t\t\tif (_this.s & 1) {\n\t\t\t\t\t_settle(result, 1, onFulfilled ? onFulfilled(value) : value);\n\t\t\t\t} else if (onRejected) {\n\t\t\t\t\t_settle(result, 1, onRejected(value));\n\t\t\t\t} else {\n\t\t\t\t\t_settle(result, 2, value);\n\t\t\t\t}\n\t\t\t} catch (e) {\n\t\t\t\t_settle(result, 2, e);\n\t\t\t}\n\t\t};\n\t\treturn result;\n\t}\n\treturn _Pact;\n})();\n\n// Settles a pact synchronously\nexport function _settle(pact, state, value) {\n\tif (!pact.s) {\n\t\tif (value instanceof _Pact) {\n\t\t\tif (value.s) {\n\t\t\t\tif (state & 1) {\n\t\t\t\t\tstate = value.s;\n\t\t\t\t}\n\t\t\t\tvalue = value.v;\n\t\t\t} else {\n\t\t\t\tvalue.o = _settle.bind(null, pact, state);\n\t\t\t\treturn;\n\t\t\t}\n\t\t}\n\t\tif (value && value.then) {\n\t\t\tvalue.then(_settle.bind(null, pact, state), _settle.bind(null, pact, 2));\n\t\t\treturn;\n\t\t}\n\t\tpact.s = state;\n\t\tpact.v = value;\n\t\tconst observer = pact.o;\n\t\tif (observer) {\n\t\t\tobserver(pact);\n\t\t}\n\t}\n}\n\nexport function _isSettledPact(thenable) {\n\treturn thenable instanceof _Pact && thenable.s & 1;\n}\n\n// Converts argument to a function that always returns a Promise\nexport function _async(f) {\n\treturn function() {\n\t\tfor (var args = [], i = 0; i < arguments.length; i++) {\n\t\t\targs[i] = arguments[i];\n\t\t}\n\t\ttry {\n\t\t\treturn Promise.resolve(f.apply(this, args));\n\t\t} catch(e) {\n\t\t\treturn Promise.reject(e);\n\t\t}\n\t}\n}\n\n// Awaits on a value that may or may not be a Promise (equivalent to the await keyword in ES2015, with continuations passed explicitly)\nexport function _await(value, then, direct) {\n\tif (direct) {\n\t\treturn then ? then(value) : value;\n\t}\n\tif (!value || !value.then) {\n\t\tvalue = Promise.resolve(value);\n\t}\n\treturn then ? value.then(then) : value;\n}\n\n// Awaits on a value that may or may not be a Promise, then ignores it\nexport function _awaitIgnored(value, direct) {\n\tif (!direct) {\n\t\treturn value && value.then ? value.then(_empty) : Promise.resolve();\n\t}\n}\n\n// Proceeds after a value has resolved, or proceeds immediately if the value is not thenable\nexport function _continue(value, then) {\n\treturn value && value.then ? value.then(then) : then(value);\n}\n\n// Proceeds after a value has resolved, or proceeds immediately if the value is not thenable\nexport function _continueIgnored(value) {\n\tif (value && value.then) {\n\t\treturn value.then(_empty);\n\t}\n}\n\n// Asynchronously iterate through an object that has a length property, passing the index as the first argument to the callback (even as the length property changes)\nexport function _forTo(array, body, check) {\n\tvar i = -1, pact, reject;\n\tfunction _cycle(result) {\n\t\ttry {\n\t\t\twhile (++i < array.length && (!check || !check())) {\n\t\t\t\tresult = body(i);\n\t\t\t\tif (result && result.then) {\n\t\t\t\t\tif (_isSettledPact(result)) {\n\t\t\t\t\t\tresult = result.v;\n\t\t\t\t\t} else {\n\t\t\t\t\t\tresult.then(_cycle, reject || (reject = _settle.bind(null, pact = new _Pact(), 2)));\n\t\t\t\t\t\treturn;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (pact) {\n\t\t\t\t_settle(pact, 1, result);\n\t\t\t} else {\n\t\t\t\tpact = result;\n\t\t\t}\n\t\t} catch (e) {\n\t\t\t_settle(pact || (pact = new _Pact()), 2, e);\n\t\t}\n\t}\n\t_cycle();\n\treturn pact;\n}\n\n// Asynchronously iterate through an object's properties (including properties inherited from the prototype)\n// Uses a snapshot of the object's properties\nexport function _forIn(target, body, check) {\n\tvar keys = [];\n\tfor (var key in target) {\n\t\tkeys.push(key);\n\t}\n\treturn _forTo(keys, function(i) { return body(keys[i]); }, check);\n}\n\n// Asynchronously iterate through an object's own properties (excluding properties inherited from the prototype)\n// Uses a snapshot of the object's properties\nexport function _forOwn(target, body, check) {\n\tvar keys = [];\n\tfor (var key in target) {\n\t\tif (Object.prototype.hasOwnProperty.call(target, key)) {\n\t\t\tkeys.push(key);\n\t\t}\n\t}\n\treturn _forTo(keys, function(i) { return body(keys[i]); }, check);\n}\n\nexport const _iteratorSymbol = /*#__PURE__*/ typeof Symbol !== \"undefined\" ? (Symbol.iterator || (Symbol.iterator = Symbol(\"Symbol.iterator\"))) : \"@@iterator\";\n\n// Asynchronously iterate through an object's values\n// Uses for...of if the runtime supports it, otherwise iterates until length on a copy\nexport function _forOf(target, body, check) {\n\tif (typeof target[_iteratorSymbol] === \"function\") {\n\t\tvar iterator = target[_iteratorSymbol](), step, pact, reject;\n\t\tfunction _cycle(result) {\n\t\t\ttry {\n\t\t\t\twhile (!(step = iterator.next()).done && (!check || !check())) {\n\t\t\t\t\tresult = body(step.value);\n\t\t\t\t\tif (result && result.then) {\n\t\t\t\t\t\tif (_isSettledPact(result)) {\n\t\t\t\t\t\t\tresult = result.v;\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tresult.then(_cycle, reject || (reject = _settle.bind(null, pact = new _Pact(), 2)));\n\t\t\t\t\t\t\treturn;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif (pact) {\n\t\t\t\t\t_settle(pact, 1, result);\n\t\t\t\t} else {\n\t\t\t\t\tpact = result;\n\t\t\t\t}\n\t\t\t} catch (e) {\n\t\t\t\t_settle(pact || (pact = new _Pact()), 2, e);\n\t\t\t}\n\t\t}\n\t\t_cycle();\n\t\tif (iterator.return) {\n\t\t\tvar _fixup = function(value) {\n\t\t\t\ttry {\n\t\t\t\t\tif (!step.done) {\n\t\t\t\t\t\titerator.return();\n\t\t\t\t\t}\n\t\t\t\t} catch(e) {\n\t\t\t\t}\n\t\t\t\treturn value;\n\t\t\t}\n\t\t\tif (pact && pact.then) {\n\t\t\t\treturn pact.then(_fixup, function(e) {\n\t\t\t\t\tthrow _fixup(e);\n\t\t\t\t});\n\t\t\t}\n\t\t\t_fixup();\n\t\t}\n\t\treturn pact;\n\t}\n\t// No support for Symbol.iterator\n\tif (!(\"length\" in target)) {\n\t\tthrow new TypeError(\"Object is not iterable\");\n\t}\n\t// Handle live collections properly\n\tvar values = [];\n\tfor (var i = 0; i < target.length; i++) {\n\t\tvalues.push(target[i]);\n\t}\n\treturn _forTo(values, function(i) { return body(values[i]); }, check);\n}\n\nexport const _asyncIteratorSymbol = /*#__PURE__*/ typeof Symbol !== \"undefined\" ? (Symbol.asyncIterator || (Symbol.asyncIterator = Symbol(\"Symbol.asyncIterator\"))) : \"@@asyncIterator\";\n\n// Asynchronously iterate on a value using it's async iterator if present, or its synchronous iterator if missing\nexport function _forAwaitOf(target, body, check) {\n\tif (typeof target[_asyncIteratorSymbol] === \"function\") {\n\t\tvar pact = new _Pact();\n\t\tvar iterator = target[_asyncIteratorSymbol]();\n\t\titerator.next().then(_resumeAfterNext).then(void 0, _reject);\n\t\treturn pact;\n\t\tfunction _resumeAfterBody(result) {\n\t\t\tif (check && check()) {\n\t\t\t\treturn _settle(pact, 1, iterator.return ? iterator.return().then(function() { return result; }) : result);\n\t\t\t}\n\t\t\titerator.next().then(_resumeAfterNext).then(void 0, _reject);\n\t\t}\n\t\tfunction _resumeAfterNext(step) {\n\t\t\tif (step.done) {\n\t\t\t\t_settle(pact, 1);\n\t\t\t} else {\n\t\t\t\tPromise.resolve(body(step.value)).then(_resumeAfterBody).then(void 0, _reject);\n\t\t\t}\n\t\t}\n\t\tfunction _reject(error) {\n\t\t\t_settle(pact, 2, iterator.return ? iterator.return().then(function() { return error; }) : error);\n\t\t}\n\t}\n\treturn Promise.resolve(_forOf(target, function(value) { return Promise.resolve(value).then(body); }, check));\n}\n\n// Asynchronously implement a generic for loop\nexport function _for(test, update, body) {\n\tvar stage;\n\tfor (;;) {\n\t\tvar shouldContinue = test();\n\t\tif (_isSettledPact(shouldContinue)) {\n\t\t\tshouldContinue = shouldContinue.v;\n\t\t}\n\t\tif (!shouldContinue) {\n\t\t\treturn result;\n\t\t}\n\t\tif (shouldContinue.then) {\n\t\t\tstage = 0;\n\t\t\tbreak;\n\t\t}\n\t\tvar result = body();\n\t\tif (result && result.then) {\n\t\t\tif (_isSettledPact(result)) {\n\t\t\t\tresult = result.s;\n\t\t\t} else {\n\t\t\t\tstage = 1;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tif (update) {\n\t\t\tvar updateValue = update();\n\t\t\tif (updateValue && updateValue.then && !_isSettledPact(updateValue)) {\n\t\t\t\tstage = 2;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\tvar pact = new _Pact();\n\tvar reject = _settle.bind(null, pact, 2);\n\t(stage === 0 ? shouldContinue.then(_resumeAfterTest) : stage === 1 ? result.then(_resumeAfterBody) : updateValue.then(_resumeAfterUpdate)).then(void 0, reject);\n\treturn pact;\n\tfunction _resumeAfterBody(value) {\n\t\tresult = value;\n\t\tdo {\n\t\t\tif (update) {\n\t\t\t\tupdateValue = update();\n\t\t\t\tif (updateValue && updateValue.then && !_isSettledPact(updateValue)) {\n\t\t\t\t\tupdateValue.then(_resumeAfterUpdate).then(void 0, reject);\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t}\n\t\t\tshouldContinue = test();\n\t\t\tif (!shouldContinue || (_isSettledPact(shouldContinue) && !shouldContinue.v)) {\n\t\t\t\t_settle(pact, 1, result);\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tif (shouldContinue.then) {\n\t\t\t\tshouldContinue.then(_resumeAfterTest).then(void 0, reject);\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tresult = body();\n\t\t\tif (_isSettledPact(result)) {\n\t\t\t\tresult = result.v;\n\t\t\t}\n\t\t} while (!result || !result.then);\n\t\tresult.then(_resumeAfterBody).then(void 0, reject);\n\t}\n\tfunction _resumeAfterTest(shouldContinue) {\n\t\tif (shouldContinue) {\n\t\t\tresult = body();\n\t\t\tif (result && result.then) {\n\t\t\t\tresult.then(_resumeAfterBody).then(void 0, reject);\n\t\t\t} else {\n\t\t\t\t_resumeAfterBody(result);\n\t\t\t}\n\t\t} else {\n\t\t\t_settle(pact, 1, result);\n\t\t}\n\t}\n\tfunction _resumeAfterUpdate() {\n\t\tif (shouldContinue = test()) {\n\t\t\tif (shouldContinue.then) {\n\t\t\t\tshouldContinue.then(_resumeAfterTest).then(void 0, reject);\n\t\t\t} else {\n\t\t\t\t_resumeAfterTest(shouldContinue);\n\t\t\t}\n\t\t} else {\n\t\t\t_settle(pact, 1, result);\n\t\t}\n\t}\n}\n\n// Asynchronously implement a do ... while loop\nexport function _do(body, test) {\n\tvar awaitBody;\n\tdo {\n\t\tvar result = body();\n\t\tif (result && result.then) {\n\t\t\tif (_isSettledPact(result)) {\n\t\t\t\tresult = result.v;\n\t\t\t} else {\n\t\t\t\tawaitBody = true;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tvar shouldContinue = test();\n\t\tif (_isSettledPact(shouldContinue)) {\n\t\t\tshouldContinue = shouldContinue.v;\n\t\t}\n\t\tif (!shouldContinue) {\n\t\t\treturn result;\n\t\t}\n\t} while (!shouldContinue.then);\n\tconst pact = new _Pact();\n\tconst reject = _settle.bind(null, pact, 2);\n\t(awaitBody ? result.then(_resumeAfterBody) : shouldContinue.then(_resumeAfterTest)).then(void 0, reject);\n\treturn pact;\n\tfunction _resumeAfterBody(value) {\n\t\tresult = value;\n\t\tfor (;;) {\n\t\t\tshouldContinue = test();\n\t\t\tif (_isSettledPact(shouldContinue)) {\n\t\t\t\tshouldContinue = shouldContinue.v;\n\t\t\t}\n\t\t\tif (!shouldContinue) {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tif (shouldContinue.then) {\n\t\t\t\tshouldContinue.then(_resumeAfterTest).then(void 0, reject);\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tresult = body();\n\t\t\tif (result && result.then) {\n\t\t\t\tif (_isSettledPact(result)) {\n\t\t\t\t\tresult = result.v;\n\t\t\t\t} else {\n\t\t\t\t\tresult.then(_resumeAfterBody).then(void 0, reject);\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t_settle(pact, 1, result);\n\t}\n\tfunction _resumeAfterTest(shouldContinue) {\n\t\tif (shouldContinue) {\n\t\t\tdo {\n\t\t\t\tresult = body();\n\t\t\t\tif (result && result.then) {\n\t\t\t\t\tif (_isSettledPact(result)) {\n\t\t\t\t\t\tresult = result.v;\n\t\t\t\t\t} else {\n\t\t\t\t\t\tresult.then(_resumeAfterBody).then(void 0, reject);\n\t\t\t\t\t\treturn;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tshouldContinue = test();\n\t\t\t\tif (_isSettledPact(shouldContinue)) {\n\t\t\t\t\tshouldContinue = shouldContinue.v;\n\t\t\t\t}\n\t\t\t\tif (!shouldContinue) {\n\t\t\t\t\t_settle(pact, 1, result);\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t} while (!shouldContinue.then);\n\t\t\tshouldContinue.then(_resumeAfterTest).then(void 0, reject);\n\t\t} else {\n\t\t\t_settle(pact, 1, result);\n\t\t}\n\t}\n}\n\n// Asynchronously implement a switch statement\nexport function _switch(discriminant, cases) {\n\tvar dispatchIndex = -1;\n\tvar awaitBody;\n\touter: {\n\t\tfor (var i = 0; i < cases.length; i++) {\n\t\t\tvar test = cases[i][0];\n\t\t\tif (test) {\n\t\t\t\tvar testValue = test();\n\t\t\t\tif (testValue && testValue.then) {\n\t\t\t\t\tbreak outer;\n\t\t\t\t}\n\t\t\t\tif (testValue === discriminant) {\n\t\t\t\t\tdispatchIndex = i;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\t// Found the default case, set it as the pending dispatch case\n\t\t\t\tdispatchIndex = i;\n\t\t\t}\n\t\t}\n\t\tif (dispatchIndex !== -1) {\n\t\t\tdo {\n\t\t\t\tvar body = cases[dispatchIndex][1];\n\t\t\t\twhile (!body) {\n\t\t\t\t\tdispatchIndex++;\n\t\t\t\t\tbody = cases[dispatchIndex][1];\n\t\t\t\t}\n\t\t\t\tvar result = body();\n\t\t\t\tif (result && result.then) {\n\t\t\t\t\tawaitBody = true;\n\t\t\t\t\tbreak outer;\n\t\t\t\t}\n\t\t\t\tvar fallthroughCheck = cases[dispatchIndex][2];\n\t\t\t\tdispatchIndex++;\n\t\t\t} while (fallthroughCheck && !fallthroughCheck());\n\t\t\treturn result;\n\t\t}\n\t}\n\tconst pact = new _Pact();\n\tconst reject = _settle.bind(null, pact, 2);\n\t(awaitBody ? result.then(_resumeAfterBody) : testValue.then(_resumeAfterTest)).then(void 0, reject);\n\treturn pact;\n\tfunction _resumeAfterTest(value) {\n\t\tfor (;;) {\n\t\t\tif (value === discriminant) {\n\t\t\t\tdispatchIndex = i;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tif (++i === cases.length) {\n\t\t\t\tif (dispatchIndex !== -1) {\n\t\t\t\t\tbreak;\n\t\t\t\t} else {\n\t\t\t\t\t_settle(pact, 1, result);\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t}\n\t\t\ttest = cases[i][0];\n\t\t\tif (test) {\n\t\t\t\tvalue = test();\n\t\t\t\tif (value && value.then) {\n\t\t\t\t\tvalue.then(_resumeAfterTest).then(void 0, reject);\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tdispatchIndex = i;\n\t\t\t}\n\t\t}\n\t\tdo {\n\t\t\tvar body = cases[dispatchIndex][1];\n\t\t\twhile (!body) {\n\t\t\t\tdispatchIndex++;\n\t\t\t\tbody = cases[dispatchIndex][1];\n\t\t\t}\n\t\t\tvar result = body();\n\t\t\tif (result && result.then) {\n\t\t\t\tresult.then(_resumeAfterBody).then(void 0, reject);\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tvar fallthroughCheck = cases[dispatchIndex][2];\n\t\t\tdispatchIndex++;\n\t\t} while (fallthroughCheck && !fallthroughCheck());\n\t\t_settle(pact, 1, result);\n\t}\n\tfunction _resumeAfterBody(result) {\n\t\tfor (;;) {\n\t\t\tvar fallthroughCheck = cases[dispatchIndex][2];\n\t\t\tif (!fallthroughCheck || fallthroughCheck()) {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tdispatchIndex++;\n\t\t\tvar body = cases[dispatchIndex][1];\n\t\t\twhile (!body) {\n\t\t\t\tdispatchIndex++;\n\t\t\t\tbody = cases[dispatchIndex][1];\n\t\t\t}\n\t\t\tresult = body();\n\t\t\tif (result && result.then) {\n\t\t\t\tresult.then(_resumeAfterBody).then(void 0, reject);\n\t\t\t\treturn;\n\t\t\t}\n\t\t}\n\t\t_settle(pact, 1, result);\n\t}\n}\n\n// Asynchronously call a function and pass the result to explicitly passed continuations\nexport function _call(body, then, direct) {\n\tif (direct) {\n\t\treturn then ? then(body()) : body();\n\t}\n\ttry {\n\t\tvar result = Promise.resolve(body());\n\t\treturn then ? result.then(then) : result;\n\t} catch (e) {\n\t\treturn Promise.reject(e);\n\t}\n}\n\n// Asynchronously call a function and swallow the result\nexport function _callIgnored(body, direct) {\n\treturn _call(body, _empty, direct);\n}\n\n// Asynchronously call a function and pass the result to explicitly passed continuations\nexport function _invoke(body, then) {\n\tvar result = body();\n\tif (result && result.then) {\n\t\treturn result.then(then);\n\t}\n\treturn then(result);\n}\n\n// Asynchronously call a function and swallow the result\nexport function _invokeIgnored(body) {\n\tvar result = body();\n\tif (result && result.then) {\n\t\treturn result.then(_empty);\n\t}\n}\n\n// Asynchronously call a function and send errors to recovery continuation\nexport function _catch(body, recover) {\n\ttry {\n\t\tvar result = body();\n\t} catch(e) {\n\t\treturn recover(e);\n\t}\n\tif (result && result.then) {\n\t\treturn result.then(void 0, recover);\n\t}\n\treturn result;\n}\n\n// Asynchronously await a promise and pass the result to a finally continuation\nexport function _finallyRethrows(body, finalizer) {\n\ttry {\n\t\tvar result = body();\n\t} catch (e) {\n\t\treturn finalizer(true, e);\n\t}\n\tif (result && result.then) {\n\t\treturn result.then(finalizer.bind(null, false), finalizer.bind(null, true));\n\t}\n\treturn finalizer(false, result);\n}\n\n// Asynchronously await a promise and invoke a finally continuation that always overrides the result\nexport function _finally(body, finalizer) {\n\ttry {\n\t\tvar result = body();\n\t} catch (e) {\n\t\treturn finalizer();\n\t}\n\tif (result && result.then) {\n\t\treturn result.then(finalizer, finalizer);\n\t}\n\treturn finalizer();\n}\n\n// Rethrow or return a value from a finally continuation\nexport function _rethrow(thrown, value) {\n\tif (thrown)\n\t\tthrow value;\n\treturn value;\n}\n\n// Empty function to implement break and other control flow that ignores asynchronous results\nexport function _empty() {\n}\n\n// Sentinel value for early returns in generators \nexport const _earlyReturn = /*#__PURE__*/ {};\n\n// Asynchronously call a function and send errors to recovery continuation, skipping early returns\nexport function _catchInGenerator(body, recover) {\n\treturn _catch(body, function(e) {\n\t\tif (e === _earlyReturn) {\n\t\t\tthrow e;\n\t\t}\n\t\treturn recover(e);\n\t});\n}\n\n// Asynchronous generator class; accepts the entrypoint of the generator, to which it passes itself when the generator should start\nexport const _AsyncGenerator = /*#__PURE__*/(function() {\n\tfunction _AsyncGenerator(entry) {\n\t\tthis._entry = entry;\n\t\tthis._pact = null;\n\t\tthis._resolve = null;\n\t\tthis._return = null;\n\t\tthis._promise = null;\n\t}\n\n\tfunction _wrapReturnedValue(value) {\n\t\treturn { value: value, done: true };\n\t}\n\tfunction _wrapYieldedValue(value) {\n\t\treturn { value: value, done: false };\n\t}\n\n\t_AsyncGenerator.prototype._yield = function(value) {\n\t\t// Yield the value to the pending next call\n\t\tthis._resolve(value && value.then ? value.then(_wrapYieldedValue) : _wrapYieldedValue(value));\n\t\t// Return a pact for an upcoming next/return/throw call\n\t\treturn this._pact = new _Pact();\n\t};\n\t_AsyncGenerator.prototype.next = function(value) {\n\t\t// Advance the generator, starting it if it has yet to be started\n\t\tconst _this = this;\n\t\treturn _this._promise = new Promise(function (resolve) {\n\t\t\tconst _pact = _this._pact;\n\t\t\tif (_pact === null) {\n\t\t\t\tconst _entry = _this._entry;\n\t\t\t\tif (_entry === null) {\n\t\t\t\t\t// Generator is started, but not awaiting a yield expression\n\t\t\t\t\t// Abandon the next call!\n\t\t\t\t\treturn resolve(_this._promise);\n\t\t\t\t}\n\t\t\t\t// Start the generator\n\t\t\t\t_this._entry = null;\n\t\t\t\t_this._resolve = resolve;\n\t\t\t\tfunction returnValue(value) {\n\t\t\t\t\t_this._resolve(value && value.then ? value.then(_wrapReturnedValue) : _wrapReturnedValue(value));\n\t\t\t\t\t_this._pact = null;\n\t\t\t\t\t_this._resolve = null;\n\t\t\t\t}\n\t\t\t\tvar result = _entry(_this);\n\t\t\t\tif (result && result.then) {\n\t\t\t\t\tresult.then(returnValue, function(error) {\n\t\t\t\t\t\tif (error === _earlyReturn) {\n\t\t\t\t\t\t\treturnValue(_this._return);\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tconst pact = new _Pact();\n\t\t\t\t\t\t\t_this._resolve(pact);\n\t\t\t\t\t\t\t_this._pact = null;\n\t\t\t\t\t\t\t_this._resolve = null;\n\t\t\t\t\t\t\t_resolve(pact, 2, error);\n\t\t\t\t\t\t}\n\t\t\t\t\t});\n\t\t\t\t} else {\n\t\t\t\t\treturnValue(result);\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\t// Generator is started and a yield expression is pending, settle it\n\t\t\t\t_this._pact = null;\n\t\t\t\t_this._resolve = resolve;\n\t\t\t\t_settle(_pact, 1, value);\n\t\t\t}\n\t\t});\n\t};\n\t_AsyncGenerator.prototype.return = function(value) {\n\t\t// Early return from the generator if started, otherwise abandons the generator\n\t\tconst _this = this;\n\t\treturn _this._promise = new Promise(function (resolve) {\n\t\t\tconst _pact = _this._pact;\n\t\t\tif (_pact === null) {\n\t\t\t\tif (_this._entry === null) {\n\t\t\t\t\t// Generator is started, but not awaiting a yield expression\n\t\t\t\t\t// Abandon the return call!\n\t\t\t\t\treturn resolve(_this._promise);\n\t\t\t\t}\n\t\t\t\t// Generator is not started, abandon it and return the specified value\n\t\t\t\t_this._entry = null;\n\t\t\t\treturn resolve(value && value.then ? value.then(_wrapReturnedValue) : _wrapReturnedValue(value));\n\t\t\t}\n\t\t\t// Settle the yield expression with a rejected \"early return\" value\n\t\t\t_this._return = value;\n\t\t\t_this._resolve = resolve;\n\t\t\t_this._pact = null;\n\t\t\t_settle(_pact, 2, _earlyReturn);\n\t\t});\n\t};\n\t_AsyncGenerator.prototype.throw = function(error) {\n\t\t// Inject an exception into the pending yield expression\n\t\tconst _this = this;\n\t\treturn _this._promise = new Promise(function (resolve, reject) {\n\t\t\tconst _pact = _this._pact;\n\t\t\tif (_pact === null) {\n\t\t\t\tif (_this._entry === null) {\n\t\t\t\t\t// Generator is started, but not awaiting a yield expression\n\t\t\t\t\t// Abandon the throw call!\n\t\t\t\t\treturn resolve(_this._promise);\n\t\t\t\t}\n\t\t\t\t// Generator is not started, abandon it and return a rejected Promise containing the error\n\t\t\t\t_this._entry = null;\n\t\t\t\treturn reject(error);\n\t\t\t}\n\t\t\t// Settle the yield expression with the value as a rejection\n\t\t\t_this._resolve = resolve;\n\t\t\t_this._pact = null;\n\t\t\t_settle(_pact, 2, error);\n\t\t});\n\t};\n\n\t_AsyncGenerator.prototype[_asyncIteratorSymbol] = function() {\n\t\treturn this;\n\t};\n\t\n\treturn _AsyncGenerator;\n})();\n","export type Method =\n  | 'get'\n  | 'GET'\n  | 'delete'\n  | 'DELETE'\n  | 'head'\n  | 'HEAD'\n  | 'options'\n  | 'OPTIONS'\n  | 'post'\n  | 'POST'\n  | 'put'\n  | 'PUT'\n  | 'patch'\n  | 'PATCH'\n  | 'purge'\n  | 'PURGE'\n  | 'link'\n  | 'LINK'\n  | 'unlink'\n  | 'UNLINK'\n\n/**\n * API request status\n */\nexport enum ViewState {\n  idle,\n  busy,\n  error\n}\n\n/**\n * API return value object\n */\nexport interface UseResult<T = unknown> {\n  success?: boolean\n  data?: T\n  message?: string\n  code?: string\n  status?: string\n  total?: number\n  isCancel?: boolean\n  other?: any\n}\n\nexport type GetDefaultBody<T> = () => T\nexport type DefaultBodyType<T> = GetDefaultBody<T> | Partial<T> | T\n\nexport type RequestType<T = unknown> = (body?: Partial<T>) => Promise<any>\nexport type BaseConfig<R = unknown, P = unknown> = {\n  status?: boolean\n  loading?: boolean\n  isDefaultSet?: boolean\n  startLoading?: () => void\n  endLoading?: () => void\n  defaultBody?: DefaultBodyType<P> // 默认请求体\n  method?: Method // 方法\n  postBody?: (body: QueryBody<P>) => any // 转换body\n  autoClear?: boolean // 自动清空\n  showMessage?: boolean // 是否显示成功失败消息\n  showErrorMessage?: boolean // 是否显示错误消息\n  showSuccessMessage?: boolean // 是否显示成功消息\n  successCallback?: (res: UseResult<R>, cache: boolean) => void\n  failCallback?: (res: UseResult<R>) => void\n  onLoadComplete?: (res: UseResult<R>) => void\n  handleHttpResult?: (res: any) => UseResult<R>\n  postData?: (data: any) => R\n  loadingDelayMs?: number\n  debounceMs?: number\n  throttleMs?: number\n  cache?: boolean | string | ((body?: P) => string[])\n  cacheKey?: boolean\n  cacheTime?: number // 设置缓存数据回收时间 默认缓存数据 5 分钟后回收\n  staleTime?: number // 缓存数据保持新鲜时间\n}\n\nexport type ErrorType = {\n  message?: string\n  code?: string\n  status?: string\n  info?: any\n}\n\nexport type StorePageConfig = {\n  usePage?: boolean\n  pageSize?: number\n}\n\nexport type SubmitConfig<R = unknown, P = unknown> = BaseConfig<R, P> &\n  QueryRunConfig\n\nexport type QueryConfig<R = unknown, P = unknown> = BaseConfig<R, P> &\n  QueryRunConfig &\n  StorePageConfig\n\nexport type RefreshConfigType = { status?: boolean; loading?: boolean }\n\nexport type QueryRunConfig = RefreshConfigType & {\n  refresh?: boolean\n}\n\nexport type HooksConfig<R, P> = SubmitConfig<R, P> & {\n  manual?: boolean // 是否手动触发\n  pollingIntervalMs?: number\n  refreshOnWindowFocus?: boolean\n  refreshOnWindowFocusMode?: 'run' | 'refresh'\n  refreshOnWindowFocusTimespanMs?: number // 重新请求间隔，单位为毫秒\n}\n\nexport type QueryHooksConfig<R, P> = QueryConfig<R, P> & HooksConfig<R, P>\nexport type SubmitHooksConfig<R, P> = HooksConfig<R, P>\n\nexport type BaseQueryStoreType = {\n  status: ViewState\n  isBusy: boolean\n  isError: boolean\n  isEmpty?: boolean\n  setStatus: (status: ViewState) => void\n  lastRequestTime?: number\n  error?: ErrorType // 错误状态\n}\n\nexport type QueryBodyStoreType<P> = {\n  body?: Partial<P>\n  setBody: (body: Partial<P>, replace?: boolean) => void\n}\n\nexport type QueryDataStoreType<R = unknown> = {\n  originData?: any\n  data?: R\n  setData: (data?: R) => void\n}\n\nexport type QueryPageStoreType<R = unknown> = {\n  current: number\n  pageSize: number\n  total: number\n  offset?: string\n  setPage: (config: {\n    current?: number\n    pageSize?: number\n  }) => Promise<UseResult<R>>\n  loadMore?: () => Promise<UseResult<R>>\n}\n\nexport type QueryRunStoreType<R, P> = {\n  cancel: (message?: string) => void\n  run: (body?: Partial<P>, config?: QueryRunConfig) => Promise<UseResult<R>>\n  refresh: (config?: RefreshConfigType) => Promise<UseResult<R>>\n  clear: () => void\n}\n\nexport type StoreType<R, P> = QueryStoreType<R, P> | SubmitStoreType<R, P>\n\nexport type QueryStoreType<R, P> = BaseQueryStoreType &\n  QueryBodyStoreType<P> &\n  QueryDataStoreType<R> &\n  QueryPageStoreType<R> &\n  QueryRunStoreType<R, P>\n\nexport type SubmitStoreType<R, P> = BaseQueryStoreType &\n  QueryBodyStoreType<P> &\n  QueryDataStoreType<R> &\n  QueryRunStoreType<R, P>\n\nexport type PaginationType = {\n  current: number\n  pageSize: number\n  total: number\n  offset?: string\n}\n\nexport type CachedData<TData = unknown, TBody = unknown> = {\n  data: TData\n  body: TBody\n  pagination?: PaginationType\n  time: number\n}\n\nexport type RequestResult = {\n  type: 'axios'\n  request: () => Promise<any>\n  source?: any\n}\n\nexport type QueryBody<P> = Partial<P> & { current?: number; pageSize?: number }\n","import { CachedData } from './model'\n\nconst dataCache: Map<string, CachedData> = new Map()\n\nexport function createCacheKey(key?: string, ids?: string[]) {\n  const prefix = 'key'\n  return `${prefix}_${key}` + ids?.map((id) => `_${id}`)\n}\n\nexport function setCache<TData, TBody>(\n  key: string,\n  data: CachedData<TData, TBody>\n) {\n  dataCache.set(key, data)\n}\n\nexport function getCache<TData, TBody>(\n  key: string\n): CachedData<TData, TBody> | undefined {\n  return dataCache.get(key) as CachedData<TData, TBody> | undefined\n}\n\nexport function clearCache(key: string) {\n  dataCache.delete(key)\n}\n","import { Art } from '../art'\nimport { AxiosError, AxiosRequestConfig, Method } from './axios'\n\nexport function getAxiosRequest(\n  method: Method,\n  url: string,\n  body: any,\n  config?: AxiosRequestConfig\n): Promise<any> {\n  switch (method) {\n    case 'POST':\n    case 'post':\n      return Art.axios!.post(url, body, config)\n    case 'PUT':\n    case 'put':\n      return Art.axios!.put(url, body, config)\n    case 'DELETE':\n    case 'delete':\n      return Art.axios!.delete(url, config)\n    default:\n      return Art.axios!.get(url, config)\n  }\n}\n\nexport function handleError(e: any) {\n  if (Art.config.axios.isCancel(e)) {\n    return { success: false, isCancel: true, message: e.message }\n  } else {\n    const response = e.response\n    if (response) {\n      const axiosRes = e as AxiosError\n      if (Art.config.handleHttpErrorResult) {\n        return {\n          message: axiosRes.message,\n          ...Art.config.handleHttpErrorResult(response),\n          success: false,\n          status: response.status,\n          isCancel: false\n        }\n      } else {\n        return {\n          success: false,\n          status: response.status,\n          code: axiosRes.code,\n          message: axiosRes.message,\n          isCancel: false\n        }\n      }\n    } else {\n      throw new Error(e)\n    }\n  }\n}\n","import {\n  CachedData,\n  DefaultBodyType,\n  GetDefaultBody,\n  Method,\n  PaginationType,\n  QueryBody,\n  QueryConfig,\n  QueryRunConfig,\n  QueryStoreType,\n  RequestResult,\n  RequestType,\n  StoreType,\n  SubmitStoreType,\n  UseResult,\n  ViewState\n} from './model'\nimport { Art } from './art'\nimport { clearCache, createCacheKey, getCache, setCache } from './cache'\nimport { getAxiosRequest, handleError } from './axios'\n\n/**\n * 处理默认请求体\n * @param store 状态管理\n * @param defaultBody 默认请求内容\n * @param body 动态请求参数\n */\nexport function updateDefaultBody<P>(\n  store: StoreType<any, P>,\n  defaultBody?: DefaultBodyType<P>,\n  body?: Partial<P>\n) {\n  let _body\n  if (defaultBody) {\n    let _defaultBody\n    if (typeof defaultBody === 'function') {\n      _defaultBody = (defaultBody as GetDefaultBody<P>)()\n    } else {\n      _defaultBody = defaultBody\n    }\n    _body = { ..._defaultBody, ...(body ?? {}) }\n  } else {\n    _body = body\n  }\n  store.body = _body\n}\n\n/**\n * 添加分页请求参数\n * @param store\n * @param usePage 是否使用分页\n */\nexport function handlePageBody<R, P>(\n  store: StoreType<R, P>,\n  usePage?: boolean\n): any {\n  let _body = store.body as any\n  if (usePage) {\n    const _store = store as QueryStoreType<R, P>\n    if (Art.config.handlePage) {\n      _body = {\n        ...(_body ?? {}),\n        ...Art.config.handlePage(_store.current, _store.pageSize)\n      }\n    } else {\n      _body = {\n        ...(_body ?? {}),\n        current: _store.current,\n        pageSize: _store.pageSize\n      }\n    }\n  }\n  return _body\n}\n\n/**\n * 转化成提交之前的请求体\n * @param body\n * @param postBody\n */\nexport function getPostBody<P>(\n  body?: QueryBody<P>,\n  postBody?: (body: QueryBody<P>) => any\n) {\n  let _body = body\n  if (postBody && _body) {\n    _body = postBody(_body)\n  }\n  return _body\n}\n\n/**\n * 自动清除\n * @param store\n * @param autoClear\n */\nexport function autoClear(store: { clear: () => void }, autoClear?: boolean) {\n  if (autoClear) {\n    store.clear()\n  }\n}\n\n/**\n * 获取当前配置项目\n * @param config\n */\nexport function getMyConfig<R, P>(\n  config?: QueryConfig<R, P>\n): QueryConfig<R, P> {\n  // 初始化默认配置\n  const defaultConfig = {\n    status: true,\n    loading: false,\n    isDefaultSet: true,\n    autoClear: false,\n    cacheTime: 300000,\n    staleTime: 0,\n    showMessage: true,\n    showSuccessMessage: false,\n    showErrorMessage: true\n  } as QueryConfig<R, P>\n  // 得到当前配置\n  // @ts-ignore\n  return { ...defaultConfig, ...(config ?? {}) }\n}\n\n/**\n * 处理开始loading\n * @param config\n */\nexport function handleStartLoading(config: {\n  loading?: boolean\n  startLoading?: () => void\n}) {\n  if (config.loading && config.startLoading) {\n    config.startLoading()\n  }\n}\n\n/**\n * 处理结束loading\n * @param config\n */\nexport function handleEndLoading(config: {\n  loading?: boolean\n  startLoading?: () => void\n}) {\n  if (config.loading && config.startLoading) {\n    config.startLoading()\n  }\n}\n\nexport async function doRequest<T, P>(\n  request: RequestResult,\n  store: SubmitStoreType<T, P>,\n  config: QueryConfig<T, P>,\n  setData: (res: UseResult<T>) => void\n): Promise<UseResult<T>> {\n  // 处理开始loading\n  handleStartLoading(config)\n\n  const setStatus = async (status: ViewState) => {\n    const loadingWait = async () => {\n      if (status !== ViewState.busy && config.loadingDelayMs) {\n        await waitTime(config.loadingDelayMs)\n      }\n    }\n\n    if (config?.status) {\n      await loadingWait()\n      store.setStatus(status)\n    }\n  }\n\n  // 发送请求\n  let myRes: UseResult<T>\n  try {\n    // 设置状态\n    await setStatus(ViewState.busy)\n    // 请求接口\n    const res = await request.request()\n    // 转换数据\n    myRes = config.handleHttpResult\n      ? config.handleHttpResult(res)\n      : Art.config.handleHttpResult\n      ? Art.config.handleHttpResult(res)\n      : res\n    // 设置原始值\n    store.originData = myRes.data\n    // 转换成前端想要的数据格式\n    if (config.postData) {\n      myRes.data = config.postData(myRes.data)\n    }\n    // 设置状态\n    await setStatus(ViewState.idle)\n  } catch (e) {\n    // 处理异常\n    myRes = handleRequestCatch(e, request) as UseResult<T>\n    if (!myRes.isCancel) {\n      // 设置状态\n      await setStatus(ViewState.error)\n    } else {\n      // 设置状态\n      await setStatus(ViewState.idle)\n    }\n  }\n\n  setData(myRes)\n\n  // 处理回调\n  handleCallback<T, P>(config, myRes)\n\n  // 处理消息\n  handleMessage<T, P>(config, myRes)\n\n  // 结束loading\n  handleEndLoading(config)\n  return myRes\n}\n\n// 处理消息\nfunction handleMessage<T, P>(config: QueryConfig<T, P>, res: UseResult) {\n  if (config.showMessage) {\n    if (\n      res.success &&\n      config.showSuccessMessage &&\n      Art.config.showSuccessMessage\n    ) {\n      Art.config.showSuccessMessage(res)\n    } else if (\n      !res.success &&\n      config.showErrorMessage &&\n      Art.config.showErrorMessage\n    ) {\n      Art.config.showErrorMessage(res)\n    }\n  }\n}\n\n// 处理回调\nfunction handleCallback<T, P>(config: QueryConfig<T, P>, res: UseResult<T>) {\n  // 请求结束\n  if (res.success) {\n    if (config.successCallback) {\n      config.successCallback(res, false)\n    }\n  } else if (!res.isCancel) {\n    if (config.failCallback) {\n      config.failCallback(res)\n    }\n  }\n  if (config.onLoadComplete) {\n    config.onLoadComplete(res)\n  }\n}\n\n/**\n * 处理请求失败\n * @param e\n * @param request\n */\nfunction handleRequestCatch(e: any, request: RequestResult): UseResult {\n  let result = { success: false, isCancel: false, message: e } as UseResult\n  if (request.type === 'axios') {\n    result = handleError(e)\n  }\n\n  if (Art.config.handleHttpError) {\n    Art.config.handleHttpError(e)\n  }\n  console.log(e)\n  return result\n}\n\n/**\n * 创建请求\n * @param request 请求或者地址\n * @param body 请求阐述\n * @param method 方法\n */\nexport function getRequest(\n  request: RequestType | string,\n  body?: any,\n  method?: Method\n): RequestResult {\n  let _request: () => Promise<any>\n\n  let source: any\n\n  if (typeof request === 'function') {\n    _request = () => request(body)\n  } else {\n    let url = request as string\n    const isPathParams = url.includes('{') && url.includes('}')\n    const _method = method ?? (isPathParams ? 'GET' : body ? 'POST' : 'GET')\n    const isPost = method === 'POST' || method === 'post'\n    if (body && typeof body === 'object' && isPathParams) {\n      Object.keys(body).forEach((key) => {\n        // @ts-ignore\n        url = url.replace(new RegExp('\\\\{' + key + '\\\\}', 'g'), body[key])\n      })\n    }\n\n    if (Art.config.axios != null) {\n      source = Art.config.axios.CancelToken.source()\n      _request = () =>\n        getAxiosRequest(_method, url, body ?? (isPost ? {} : undefined), {\n          cancelToken: source.token\n        })\n    } else {\n      throw new Error('Coco 必须实例化 http 组件，目前支持axios')\n    }\n  }\n  return { request: _request, type: 'axios', source }\n}\n\nexport function setBody<P>(\n  store: { body?: Partial<P> },\n  inBody: Partial<P>,\n  replace = false\n): void {\n  const { body } = store\n  if (body && !replace) {\n    store.body = { ...inBody, ...store.body }\n  } else {\n    store.body = inBody\n  }\n}\n\n/**\n * 延迟等待\n * @param time 等待时间\n */\nexport const waitTime = (time = 100) => {\n  return new Promise((resolve) => {\n    setTimeout(() => {\n      resolve(true)\n    }, time)\n  })\n}\n\n/**\n * 处理请求\n * @param request\n * @param config\n */\nexport function doRun<R, P>(\n  request: (\n    body?: Partial<P>,\n    config?: QueryRunConfig\n  ) => Promise<UseResult<R>>,\n  config: QueryConfig<R, P>\n) {\n  if (config.throttleMs) {\n    return throttle(request, config.throttleMs)\n  }\n  return debounce(request, config.debounceMs)\n}\n\n// 防抖函数\nexport function debounce<R, P>(\n  request: (\n    body?: Partial<P>,\n    config?: QueryRunConfig\n  ) => Promise<UseResult<R>>,\n  ms?: number\n) {\n  let timeout: any\n  return (\n    body?: Partial<P>,\n    config?: QueryRunConfig\n  ): Promise<UseResult<R>> => {\n    clearTimeout(timeout)\n    return new Promise((resolve) => {\n      if (ms) {\n        timeout = setTimeout(() => {\n          resolve(request(body, config))\n        }, ms)\n      } else {\n        resolve(request(body, config))\n      }\n    })\n  }\n}\n\n// 节流函数\nexport function throttle<R, P>(\n  request: (\n    body?: Partial<P>,\n    config?: QueryRunConfig\n  ) => Promise<UseResult<R>>,\n  waitMs: number\n) {\n  let timeout: any\n  let old = 0\n  return (\n    body?: Partial<P>,\n    config?: QueryRunConfig\n  ): Promise<UseResult<R>> => {\n    return new Promise((resolve) => {\n      const now = new Date().valueOf()\n      if (!old) {\n        old = now\n      }\n      if (now - old > waitMs) {\n        if (timeout) {\n          clearTimeout(timeout)\n          timeout = null\n        }\n        resolve(request(body, config))\n        old = now\n      } else if (!timeout) {\n        timeout = setTimeout(() => {\n          old = new Date().valueOf()\n          timeout = null\n          resolve(request(body, config))\n        }, waitMs)\n      }\n    })\n  }\n}\n\n/**\n * 处理数据缓存\n * @param config\n * @param request\n * @param store\n * @param res\n */\nexport function setStoreCacheData<R, P>(\n  config: QueryConfig<R, P>,\n  request: RequestType<P> | string,\n  store: StoreType<R, P>,\n  res: UseResult<R>\n) {\n  if (!config.cache) {\n    return\n  }\n\n  const key = getCacheKey(config, request, store)\n\n  let pagination: PaginationType | undefined\n  try {\n    if (config.usePage) {\n      const { current, pageSize, total, offset } = store as QueryStoreType<R, P>\n      pagination = { current, pageSize, total, offset }\n    }\n  } catch (e) {}\n\n  setCache<UseResult<R>, P>(key, {\n    body: store.body as P,\n    data: res,\n    time: new Date().getTime(),\n    pagination\n  })\n}\n\nexport function getStoreCacheData<R, P>(\n  config: QueryConfig<R, P>,\n  request: RequestType<P> | string,\n  store: StoreType<R, P>\n) {\n  if (!config.cache) {\n    return { cache: undefined, active: false }\n  }\n\n  const key = getCacheKey(config, request, store)\n\n  const cache = getCache<UseResult<R>, P>(key)\n\n  if (cache) {\n    const cacheTime = config.cacheTime ?? 300000\n    if (cacheTime < 0 || new Date().getTime() - cache.time <= cacheTime) {\n      return { cache, active: true }\n    } else {\n      clearCache(key)\n    }\n  }\n  return { cache: undefined, active: false }\n}\n\nexport function getCacheRequest<R, P>(\n  config: QueryConfig<R, P>,\n  cache: CachedData<UseResult<R>, P>,\n  store: StoreType<R, P>\n): Promise<UseResult<R>> {\n  const res = cache.data\n  if (config.successCallback) {\n    config.successCallback(res, true)\n  }\n  if (cache.pagination) {\n    try {\n      const _store = store as QueryStoreType<R, P>\n      const { current, pageSize, total, offset } = cache.pagination\n      _store.current = current\n      _store.pageSize = pageSize\n      _store.total = total\n      _store.offset = offset\n    } catch (e) {}\n  }\n  store.data = cache.data.data\n  store.body = cache.body\n\n  // 控制新鲜度, 如果过期新鲜度\n  const staleTime = config.staleTime ?? 0\n  if (staleTime >= 0 && new Date().getTime() - cache.time > staleTime) {\n    store.refresh().then()\n  }\n  return new Promise((resolve) => resolve(res))\n}\n\nexport function getCacheKey<R, P>(\n  config: QueryConfig<R, P>,\n  request: RequestType<P> | string,\n  store: StoreType<R, P>\n) {\n  let key\n\n  if (config.cache === true || typeof config.cache === 'function') {\n    if (typeof request === 'function') {\n      throw new Error('request是url的形式的时候，cache只能是字符串')\n    }\n  }\n  if (typeof config.cache === 'string') {\n    key = createCacheKey(config.cache)\n  } else if (typeof config.cache === 'function') {\n    const ids = config.cache(store.body as P)\n    key = createCacheKey(request as string, ids)\n  } else {\n    key = createCacheKey(request as string)\n  }\n  if (config.usePage) {\n    const { current, pageSize, offset } = store as QueryStoreType<R, P>\n    return `${key}_${current}_${pageSize}` + offset ? `'_${offset}'` : ''\n  }\n  return key\n}\n","import React, { useEffect } from 'react'\n// @ts-ignore\nconst document: any = window ? window.document : undefined\nconst visible = 'visible'\n\n/**\n * 检查浏览器标签切换\n */\nexport const useBrowserPageChange = () => {\n  const [visibilityChange, setVisibilityChange] = React.useState<boolean>(false)\n\n  const getHiddenProp = () => {\n    if (!document) {\n      return null\n    }\n    const prefixes = ['webkit', 'moz', 'ms', 'o']\n\n    // if 'hidden' is natively supported just return it\n    if ('hidden' in document) {\n      return 'hidden'\n    }\n\n    // otherwise loop over all the known prefixes until we find one\n    for (let i = 0; i < prefixes.length; i++) {\n      if (prefixes[i] + 'Hidden' in document) return prefixes[i] + 'Hidden'\n    }\n\n    // otherwise it's not supported\n    return null\n  }\n\n  const getVisibilityState = () => {\n    const prefixes = ['webkit', 'moz', 'ms', 'o']\n    if ('visibilityState' in document) return 'visibilityState'\n    for (let i = 0; i < prefixes.length; i++) {\n      if (prefixes[i] + 'VisibilityState' in document)\n        return prefixes[i] + 'VisibilityState'\n    }\n    // otherwise it's not supported\n    return null\n  }\n\n  useEffect(() => {\n    const eventName =\n      (getHiddenProp() ?? '').replace(/[H|h]idden/, '') + 'visibilitychange'\n    if (getHiddenProp()) {\n      document.addEventListener(\n        eventName,\n        function () {\n          setVisibilityChange(document[getVisibilityState() ?? ''] === visible)\n        },\n        false\n      )\n    }\n    return () => {\n      document.removeEventListener(eventName, function () {\n        setVisibilityChange(document[getVisibilityState() ?? ''] === visible)\n      })\n    }\n  }, [getHiddenProp()])\n\n  return { visibilityChange }\n}\n","import { DependencyList, useEffect, useMemo } from 'react'\nimport {\n  autoClear,\n  doRequest,\n  doRun,\n  getCacheRequest,\n  getMyConfig,\n  getPostBody,\n  getRequest,\n  getStoreCacheData,\n  handlePageBody,\n  setBody,\n  setStoreCacheData,\n  updateDefaultBody\n} from './utils'\nimport {\n  QueryConfig,\n  QueryHooksConfig,\n  QueryRunConfig,\n  QueryStoreType,\n  RequestResult,\n  RequestType,\n  UseResult,\n  ViewState\n} from './model'\nimport resso from 'resso'\nimport { useBrowserPageChange } from './hooks/browser-page-hooks'\n\nexport function createQueryStore<\n  R = Record<string, any> | string,\n  P = Record<string, any>\n>(request: RequestType<P> | string, config?: QueryConfig<R, P>) {\n  // 得到当前配置\n  let myConfig = getMyConfig<R, P>(config) as QueryConfig<R, P>\n\n  // 当前请求\n  let currentRequest: RequestResult | undefined\n\n  // 设置返回数据\n  function setResData(res: UseResult<R>) {\n    if (res.success) {\n      if (myConfig.isDefaultSet) {\n        store.setData(res.data)\n        store.total = res.total ?? 0\n      }\n      if (myConfig?.status && store?.status !== ViewState.error) {\n        store.isEmpty =\n          !res.data ||\n          (res.data && res.data instanceof Array && !res.data.length)\n      }\n      // 记录最后时间\n      store.lastRequestTime = new Date().getTime()\n\n      // 处理缓存\n      setStoreCacheData(myConfig, request, store, res)\n    } else if (!res.isCancel) {\n      store.error = { message: res.message, code: res.code, status: res.status }\n    }\n  }\n\n  // 创建store\n  const store = resso<QueryStoreType<R, P>>({\n    isBusy: false,\n    isError: false,\n    status: ViewState.idle,\n    isEmpty: undefined,\n    error: undefined,\n    setStatus: (status: ViewState) => {\n      store.status = status\n      store.isError = status === ViewState.error\n      store.isBusy = status === ViewState.busy\n    },\n    lastRequestTime: undefined,\n    body: undefined,\n    setBody: (inBody: Partial<P>, replace = false) => {\n      setBody<P>(store, inBody, replace)\n    },\n    current: 1,\n    pageSize: config?.pageSize ?? 10,\n    total: 0,\n    offset: undefined,\n    setPage: (config): Promise<UseResult<R>> => {\n      const { current, pageSize } = config ?? {}\n      if (current) {\n        store.current = current\n      }\n      if (pageSize) {\n        store.pageSize = pageSize\n      }\n      return store.run()\n    },\n    originData: undefined,\n    data: undefined,\n    setData: (data?: R) => {\n      store.data = data\n    },\n    refresh: (config): Promise<UseResult<R>> => {\n      myConfig = {\n        ...myConfig,\n        loading: false,\n        status: false,\n        ...(config ?? {}),\n        refresh: true\n      }\n      if (!currentRequest) {\n        return store.run(undefined, myConfig)\n      } else {\n        return doRequest<R, P>(currentRequest, store, myConfig, setResData)\n      }\n    },\n    run: doRun<R, P>(\n      (body?: Partial<P>, config?: QueryRunConfig): Promise<UseResult<R>> => {\n        myConfig = { ...myConfig, ...config }\n        // 清除\n        autoClear(store, myConfig.autoClear)\n\n        console.log(store)\n        // 获取缓存\n        const { cache, active } = getStoreCacheData<R, P>(\n          myConfig,\n          request,\n          store\n        )\n        // 如果有缓存 并且缓存有效\n        if (!config?.refresh && cache && active) {\n          return getCacheRequest<R, P>(myConfig, cache, store)\n        } else {\n          // 设置body\n          updateDefaultBody<P>(store, myConfig.defaultBody, body)\n          // 处理分页\n          let _body = handlePageBody(store, myConfig.usePage)\n          // 获取准备提交的请求体\n          _body = getPostBody(_body, myConfig.postBody)\n          // 获取请求体\n          currentRequest = getRequest(request, _body, myConfig.method)\n          // 发送请求\n          return doRequest<R, P>(currentRequest, store, myConfig, setResData)\n        }\n      },\n      myConfig\n    ),\n    cancel: (message?: string) => {\n      if (currentRequest) {\n        if (currentRequest.type === 'axios') {\n          // eslint-disable-next-line no-unused-expressions\n          currentRequest.source?.cancel(message)\n        }\n      }\n    },\n    clear: () => {\n      store.data = undefined\n      store.body = undefined\n      store.total = 0\n      store.current = 1\n      store.isEmpty = undefined\n    }\n  })\n  return store\n}\n\nexport function useQuery<\n  R = Record<string, any> | string,\n  P = Record<string, any>\n>(\n  request: RequestType<P> | string,\n  config?: QueryHooksConfig<R, P>,\n  deps?: DependencyList\n) {\n  const store = useMemo(() => createQueryStore(request, config), deps ?? [])\n  useEffect(() => {\n    const manual = config?.manual ?? false\n    if (!manual) {\n      store.run().then()\n    }\n    let interval: any\n    if (config?.pollingIntervalMs) {\n      if (interval) {\n        clearInterval(interval)\n      }\n      interval = setInterval(() => {\n        store.run().then()\n      }, config?.pollingIntervalMs)\n    }\n    return () => {\n      if (interval) {\n        clearInterval(interval)\n      }\n      store.cancel()\n    }\n  }, deps ?? [])\n\n  const { visibilityChange } = useBrowserPageChange()\n\n  useEffect(() => {\n    if (config?.refreshOnWindowFocus && visibilityChange) {\n      if (\n        !store.lastRequestTime ||\n        new Date().getTime() - store.lastRequestTime >\n          (config?.refreshOnWindowFocusTimespanMs ?? 0)\n      )\n        if (config?.refreshOnWindowFocusMode === 'run') {\n          store.run().then()\n        } else {\n          store.refresh().then()\n        }\n    }\n  }, [visibilityChange])\n  return store\n}\n","import { DependencyList, useEffect, useMemo } from 'react'\nimport {\n  autoClear,\n  doRequest,\n  doRun,\n  getCacheRequest,\n  getMyConfig,\n  getPostBody,\n  getRequest,\n  getStoreCacheData,\n  handlePageBody,\n  setBody,\n  setStoreCacheData,\n  updateDefaultBody\n} from './utils'\nimport {\n  QueryConfig,\n  QueryRunConfig,\n  RequestResult,\n  RequestType,\n  SubmitConfig,\n  SubmitHooksConfig,\n  SubmitStoreType,\n  UseResult,\n  ViewState\n} from './model'\nimport resso from 'resso'\nimport { useBrowserPageChange } from './hooks/browser-page-hooks'\n\nexport function createSubmitStore<\n  R = Record<string, any> | string,\n  P = Record<string, any>\n>(request: RequestType<P> | string, config?: SubmitConfig<R, P>) {\n  // 得到当前配置\n  let myConfig = getMyConfig<R, P>(config) as QueryConfig<R, P>\n\n  // 当前请求\n  let currentRequest: RequestResult\n\n  // 设置返回数据\n  function setResData(res: UseResult<R>) {\n    if (res.success) {\n      if (myConfig.isDefaultSet) {\n        store.setData(res.data)\n      }\n      if (myConfig?.status && store?.status !== ViewState.error) {\n        store.isEmpty =\n          !res.data ||\n          (res.data && res.data instanceof Array && !res.data.length)\n      }\n      // 记录最后时间\n      store.lastRequestTime = new Date().getTime()\n\n      // 处理缓存\n      setStoreCacheData(myConfig, request, store, res)\n    } else if (!res.isCancel) {\n      store.error = { message: res.message, code: res.code, status: res.status }\n    }\n  }\n\n  // 创建store\n  const store = resso<SubmitStoreType<R, P>>({\n    isBusy: false,\n    isError: false,\n    status: ViewState.idle,\n    isEmpty: undefined,\n    error: undefined,\n    setStatus: (status: ViewState) => {\n      store.status = status\n      store.isError = status === ViewState.error\n      store.isBusy = status === ViewState.busy\n    },\n    lastRequestTime: undefined,\n    body: undefined,\n    setBody: (inBody: Partial<P>, replace = false) => {\n      setBody<P>(store, inBody, replace)\n    },\n    originData: undefined,\n    data: undefined,\n    setData: (data?: R) => {\n      store.data = data\n    },\n    refresh: (config): Promise<UseResult<R>> => {\n      myConfig = {\n        ...myConfig,\n        loading: false,\n        status: false,\n        ...(config ?? {}),\n        refresh: true\n      }\n      if (!currentRequest) {\n        return store.run(undefined, myConfig)\n      } else {\n        return doRequest<R, P>(currentRequest, store, myConfig, setResData)\n      }\n    },\n    run: doRun<R, P>(\n      (body?: Partial<P>, config?: QueryRunConfig): Promise<UseResult<R>> => {\n        myConfig = { ...myConfig, ...config }\n        // 清除\n        autoClear(store, myConfig.autoClear)\n        // 获取缓存\n        const { cache, active } = getStoreCacheData<R, P>(\n          myConfig,\n          request,\n          store\n        )\n        // 如果有缓存 并且缓存有效\n        if (!config?.refresh && cache && active) {\n          return getCacheRequest<R, P>(myConfig, cache, store)\n        } else {\n          // 设置body\n          updateDefaultBody<P>(store, myConfig.defaultBody, body)\n          // 处理分页\n          let _body = handlePageBody(store, myConfig.usePage)\n          // 获取准备提交的请求体\n          _body = getPostBody(_body, myConfig.postBody)\n          // 获取请求体\n          currentRequest = getRequest(request, _body, myConfig.method)\n          // 发送请求\n          return doRequest<R, P>(currentRequest, store, myConfig, setResData)\n        }\n      },\n      myConfig\n    ),\n    cancel: (message?: string) => {\n      if (currentRequest) {\n        if (currentRequest.type === 'axios') {\n          // eslint-disable-next-line no-unused-expressions\n          currentRequest.source?.cancel(message)\n        }\n      }\n    },\n    clear: () => {\n      store.data = undefined\n      store.body = undefined\n      store.isEmpty = undefined\n    }\n  })\n  return store\n}\n\nexport function useSubmit<\n  R = Record<string, any> | string,\n  P = Record<string, any>\n>(\n  request: RequestType<P> | string,\n  config?: SubmitHooksConfig<R, P>,\n  deps?: DependencyList\n) {\n  const store = useMemo(() => createSubmitStore(request, config), deps ?? [])\n  useEffect(() => {\n    const manual = config?.manual ?? true\n    if (!manual) {\n      store.run().then()\n    }\n    let interval: any\n    if (config?.pollingIntervalMs) {\n      if (interval) {\n        clearInterval(interval)\n      }\n      interval = setInterval(() => {\n        store.run().then()\n      }, config?.pollingIntervalMs)\n    }\n    return () => {\n      if (interval) {\n        clearInterval(interval)\n      }\n      store.cancel()\n    }\n  }, deps ?? [])\n\n  const { visibilityChange } = useBrowserPageChange()\n\n  useEffect(() => {\n    if (config?.refreshOnWindowFocus && visibilityChange) {\n      if (\n        !store.lastRequestTime ||\n        new Date().getTime() - store.lastRequestTime >\n          (config?.refreshOnWindowFocusTimespanMs ?? 0)\n      )\n        if (config?.refreshOnWindowFocusMode === 'run') {\n          store.run().then()\n        } else {\n          store.refresh().then()\n        }\n    }\n  }, [visibilityChange])\n  return store\n}\n"]},"metadata":{},"sourceType":"module"}